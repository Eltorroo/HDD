<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand Drawn Dog Competition</title>
    <style>
        :root {
            /* Brand Colors: Warm, Earthy yet Premium */
            --c-cream: #FDFBF7;
            --c-surface: #FFFFFF;
            --c-surface-alt: #F3F4F6;
            
            --c-primary: #D97706; /* Warm Amber */
            --c-primary-hover: #B45309;
            --c-secondary: #78350F; /* Deep Brown */
            
            --c-text-main: #1F2937;
            --c-text-muted: #6B7280;
            
            --c-accent-teal: #14B8A6;
            --c-accent-rose: #F43F5E;

            --radius-md: 12px;
            --radius-lg: 16px;
            --radius-pill: 9999px;
            
            --shadow-sm: 0 1px 2px rgba(0,0,0,0.05);
            --shadow-md: 0 4px 6px -1px rgba(0,0,0,0.1);
            --shadow-lg: 0 10px 15px -3px rgba(0,0,0,0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --c-cream: #111827;
                --c-surface: #1F2937;
                --c-surface-alt: #374151;
                --c-text-main: #F9FAFB;
                --c-text-muted: #9CA3AF;
            }
        }

        * { margin: 0; padding: 0; box-sizing: border-box; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }

        body {
            background-color: var(--c-cream);
            color: var(--c-text-main);
            line-height: 1.5;
            padding-bottom: 40px;
        }

        /* --- HERO SECTION --- */
        .hero {
            background: linear-gradient(135deg, var(--c-surface) 0%, var(--c-surface-alt) 100%);
            padding: 60px 20px 40px;
            text-align: center;
            border-bottom: 1px solid rgba(0,0,0,0.05);
        }

        .hero h1 {
            font-size: 3rem;
            font-weight: 800;
            color: var(--c-secondary);
            margin-bottom: 16px;
            letter-spacing: -0.02em;
        }

        .hero p {
            font-size: 1.25rem;
            color: var(--c-text-muted);
            max-width: 600px;
            margin: 0 auto 32px;
        }

        .hero-stats {
            display: flex;
            justify-content: center;
            gap: 24px;
            margin-bottom: 32px;
            font-size: 0.9rem;
            color: var(--c-text-muted);
        }

        .hero-stats strong { color: var(--c-primary); }

        .btn-cta {
            background: var(--c-primary);
            color: white;
            font-size: 1.1rem;
            font-weight: 600;
            padding: 16px 48px;
            border-radius: var(--radius-pill);
            border: none;
            cursor: pointer;
            box-shadow: var(--shadow-md);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn-cta:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
            background: var(--c-primary-hover);
        }

        /* --- STICKY NAV --- */
        .nav-container {
            position: sticky;
            top: 0;
            z-index: 100;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(0,0,0,0.05);
            padding: 10px 20px;
            margin-bottom: 40px;
        }
        
        @media (prefers-color-scheme: dark) {
            .nav-container { background: rgba(31, 41, 55, 0.9); }
        }

        .nav-tabs {
            display: flex;
            justify-content: center;
            gap: 8px;
            max-width: 800px;
            margin: 0 auto;
        }

        .nav-tab {
            padding: 10px 20px;
            border-radius: var(--radius-pill);
            border: none;
            background: transparent;
            color: var(--c-text-muted);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .nav-tab:hover { background: var(--c-surface-alt); color: var(--c-text-main); }
        .nav-tab.active { background: var(--c-text-main); color: var(--c-surface); }

        /* --- LAYOUT --- */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        .tab-content { display: none; animation: fadeIn 0.4s ease; }
        .tab-content.active { display: block; }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* --- DRAWING INTERFACE --- */
        .drawing-card {
            background: var(--c-surface);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-md);
            padding: 24px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            justify-content: center;
            margin-bottom: 20px;
            background: var(--c-surface-alt);
            padding: 12px;
            border-radius: var(--radius-md);
            width: 100%;
        }

        .tool-btn {
            width: 44px;
            height: 44px;
            border-radius: 8px;
            border: 2px solid transparent;
            background: var(--c-surface);
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.2s;
            display: grid;
            place-items: center;
        }

        .tool-btn.active { border-color: var(--c-primary); color: var(--c-primary); background: #FFF7ED; }
        .tool-btn:hover:not(.active) { background: #E5E7EB; }

        .canvas-wrapper {
            position: relative;
            box-shadow: var(--shadow-md);
            border-radius: 8px;
            overflow: hidden;
            border: 4px solid var(--c-text-main); /* Frame effect */
            margin: 20px auto;
            background: white;
            max-width: 600px;
            width: 100%;
        }
        /* --- TOURNAMENT STYLES --- */
        .tournament-tab {
            background: linear-gradient(135deg, #D97706 0%, #F59E0B 100%);
            color: white !important;
            font-weight: 700;
        }
        
        .tournament-tab:hover {
            background: linear-gradient(135deg, #B45309 0%, #D97706 100%);
        }
        
        .tournament-container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .tournament-welcome {
            text-align: center;
            padding: 40px 20px;
        }
        
        .tournament-welcome h1 {
            font-size: 2.5rem;
            margin-bottom: 16px;
            color: var(--c-primary);
        }
        
        .tournament-btn {
            padding: 16px 32px;
            font-size: 1.1rem;
            font-weight: 700;
            border: none;
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: all 0.3s;
            background: var(--c-primary);
            color: white;
        }
        
        .tournament-btn:hover {
            background: var(--c-primary-hover);
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }


        /* --- GALLERY GRID --- */
        .gallery-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 24px;
        }

        .art-card {
            background: var(--c-surface);
            border-radius: var(--radius-md);
            overflow: hidden;
            box-shadow: var(--shadow-sm);
            transition: transform 0.2s;
            border: 1px solid rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
        }

        .art-card:hover { transform: translateY(-4px); box-shadow: var(--shadow-lg); }

        .art-image {
            width: 100%;
            aspect-ratio: 4/3;
            object-fit: contain;
            background: white;
            border-bottom: 1px solid var(--c-surface-alt);
        }

        .art-info { padding: 16px; flex: 1; display: flex; flex-direction: column; }
        .art-title { font-weight: 700; margin-bottom: 4px; font-size: 1.1rem; }
        .art-meta { color: var(--c-text-muted); font-size: 0.9rem; margin-bottom: 12px; display: flex; justify-content: space-between; }
        
        .vote-btn {
            margin-top: auto;
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            transition: background 0.2s;
        }

        .vote-btn.can-vote { background: var(--c-surface-alt); color: var(--c-text-main); }
        .vote-btn.can-vote:hover { background: var(--c-accent-rose); color: white; }
        
        .vote-btn.voted { background: var(--c-accent-teal); color: white; cursor: default; }
        .vote-btn.own-art { background: #E5E7EB; color: #9CA3AF; cursor: not-allowed; }

        /* --- INPUTS --- */
        .input-group { margin-bottom: 16px; width: 100%; max-width: 400px; text-align: left; }
        .input-label { display: block; margin-bottom: 6px; font-weight: 600; font-size: 0.9rem; }
        .form-control {
            width: 100%;
            padding: 10px 14px;
            border: 1px solid #D1D5DB;
            border-radius: 8px;
            font-size: 1rem;
            background: var(--c-surface);
            color: var(--c-text-main);
        }
        .form-control:focus { outline: 2px solid var(--c-primary); border-color: transparent; }

        /* --- NOTIFICATIONS --- */
        .toast {
            position: fixed;
            bottom: 24px;
            right: 24px;
            padding: 16px 24px;
            background: var(--c-text-main);
            color: white;
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-lg);
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            z-index: 1000;
        }
        .toast.show { transform: translateY(0); opacity: 1; }
        .toast.success { border-left: 4px solid var(--c-accent-teal); }
        .toast.error { border-left: 4px solid var(--c-accent-rose); }

        /* --- LEADERBOARD --- */
        .rank-row {
            display: flex;
            align-items: center;
            padding: 12px;
            border-bottom: 1px solid var(--c-surface-alt);
        }
        .rank-num { font-size: 1.5rem; font-weight: 800; width: 50px; text-align: center; color: var(--c-text-muted); }
        .rank-1 { color: #F59E0B; }
        .rank-2 { color: #9CA3AF; }
        .rank-3 { color: #B45309; }

        @media (max-width: 768px) {
            .hero h1 { font-size: 2rem; }
            .canvas-wrapper canvas { width: 100%; height: auto; }
            .nav-tabs { overflow-x: auto; justify-content: flex-start; padding-bottom: 4px; }
            .nav-tab { white-space: nowrap; }
        }
/* --- MODAL STYLES --- */
.art-modal {
    display: none;
    position: fixed;
    z-index: 2000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.9);
    backdrop-filter: blur(5px);
    cursor: zoom-out;
}

.modal-content {
    margin: auto;
    display: block;
    max-width: 90%;
    max-height: 80vh;
    border: 5px solid white;
    border-radius: 8px;
    margin-top: 5vh;
    cursor: default;
}

.close-modal {
    position: absolute;
    top: 20px;
    right: 35px;
    color: #f1f1f1;
    font-size: 60px;
    font-weight: bold;
    cursor: pointer;
    line-height: 1;
}

.modal-caption {
    margin: auto;
    display: block;
    width: 80%;
    text-align: center;
    color: white;
    padding: 20px 0;
    font-size: 1.5rem;
    font-weight: bold;
}
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>

    <header class="hero">
        <h1>üêæ Hand Drawn Dog Competition</h1>
        <p>Show off your artistic skills. Draw a dog, get votes, and become the top artist.</p>
        
        <div class="hero-stats">
            <span><strong id="statTotalDrawings">0</strong> Drawings</span>
            <span>‚Ä¢</span>
            <span><strong id="statTotalVotes">0</strong> Votes Cast</span>
        </div>

        <button class="btn-cta" onclick="activateTab('draw')">‚úèÔ∏è Start Drawing Now</button>
    </header>

    <nav class="nav-container">
    <div class="nav-tabs">
        <button class="nav-tab active" onclick="activateTab('draw')">Draw</button>
        <button class="nav-tab" onclick="activateTab('gallery')">Gallery</button>
        <button class="nav-tab" onclick="activateTab('leaderboard')">Leaderboard</button>
        <button class="nav-tab" onclick="activateTab('accuracy')">Accuracy</button>
        <button class="nav-tab tournament-tab" onclick="activateTab('tournament')">üèÜ Tournament</button>
    </div>
</nav>


    <div class="container">
        
        <div id="draw" class="tab-content active">
            <div class="input-group">
                <label class="input-label">1. Give Your Drawing a Title</label>
                <input type="text" id="dogTitle" class="form-control" placeholder="Your Dog Title" maxlength="50">
            </div>

            <div class="input-group">
                <label class="input-label">Choose a Reference (Optional)</label>
                <select id="refSelect" class="form-control">
                    <option value="">Select a dog photo...</option>
                </select>
            </div>

            <div class="toolbar">
                <button class="tool-btn active" id="btnPen" title="Pen">üñäÔ∏è</button>
                <button class="tool-btn" id="btnBrush" title="Brush">üñåÔ∏è</button>
                <button class="tool-btn" id="btnEraser" title="Eraser">üßπ</button>
                <button class="tool-btn" id="btnFill" title="Fill">ü™£</button>
                <div style="width: 1px; background: #ddd; margin: 0 8px;"></div>
                <input type="color" id="colorPicker" value="#000000" style="height: 44px; width: 44px; padding: 0; border: none; cursor: pointer;">
<div style="width: 1px; background: #ddd; margin: 0 8px;"></div>
<div style="display: flex; flex-direction: column; align-items: center; gap: 2px;">
    <span style="font-size: 0.7rem; font-weight: bold; color: var(--c-text-muted);">SIZE</span>
    <input type="range" id="sizeSlider" min="1" max="50" value="3" style="width: 80px; cursor: pointer;">
</div>
                <div style="width: 1px; background: #ddd; margin: 0 8px;"></div>
                <button class="tool-btn" id="btnUndo" title="Undo">‚Ü∂</button>
                <button class="tool-btn" id="btnClear" title="Clear">üóëÔ∏è</button>
            </div>

            <div class="canvas-wrapper">
                <canvas id="refCanvas" width="600" height="450" style="position: absolute; pointer-events: none; opacity: 0;"></canvas>
                <canvas id="overlayCanvas" width="600" height="450" style="position: absolute; pointer-events: none; top:0; left:0;"></canvas>
<div id="tournamentStatusHeader" style="display:none; width:100%; background:var(--c-primary); color:white; padding:10px; border-radius:8px 8px 0 0; text-align:center; font-weight:bold; margin-bottom:-4px;">
    üèÜ TOERNOOI MODUS: <span id="tournamentRoundName">Ronde 1</span> - <span id="tournamentTimeDisplay">03:00</span>
</div>
                <canvas id="drawCanvas" width="600" height="450"></canvas>
            </div>

            <div class="input-group" style="display: flex; gap: 10px; align-items: flex-end; margin-top: 20px;">
                <div style="flex: 1;">
                    <label class="input-label">2. Sign your Masterpiece</label>
                    <input type="text" id="artistName" class="form-control" placeholder="Your Artist Name" maxlength="30">
                </div>
                <button class="btn-cta" id="btnSubmit" style="padding: 10px 24px; font-size: 1rem;">Publish</button>
            </div>
            
            <div style="margin-top: 10px;">
                    <label style="font-size: 0.9rem; color: var(--c-text-muted);">
                    <input type="checkbox" id="toggleRef" disabled> Show Reference Overlay
                </label>
                <input type="range" id="opacitySlider" min="0" max="100" value="30" disabled style="vertical-align: middle;">
            </div>
        </div>

        <div id="gallery" class="tab-content">
            <div style="margin-bottom: 20px; display: flex; justify-content: space-between; align-items: center;">
                <h2>Latest Submissions</h2>
                <span style="font-size: 0.9rem; color: var(--c-text-muted);">Sorted by Popularity</span>
            </div>
            <div id="galleryGrid" class="gallery-grid"></div>
        </div>

        <div id="leaderboard" class="tab-content">
            <div class="drawing-card" style="align-items: stretch; max-width: 800px; margin: 0 auto;">
                <h2 style="text-align: center; margin-bottom: 20px;">üèÜ Hall of Fame</h2>
                <div id="leaderboardList"></div>
            </div>
        </div>

        <div id="accuracy" class="tab-content">
            <div class="drawing-card" style="align-items: stretch; max-width: 800px; margin: 0 auto;">
                <h2 style="text-align: center; margin-bottom: 10px;">üéØ Smart Accuracy Scores</h2>
                <p style="text-align: center; color: var(--c-text-muted); margin-bottom: 30px;">
                    Our algorithm analyzes color matching and shape composition.
                </p>
                <div id="accuracyList"></div>
            </div>
        </div>

        <div class="tab-content" id="tournament">
            <div class="tournament-container">
                <div id="tournamentWelcome" class="tournament-welcome">
                    <h1>üèÜ Tournament Mode</h1>
                    <p style="font-size: 1.1rem; color: var(--c-text-muted); margin-bottom: 32px;">
                        Competitive drawing competition against other players!
                    </p>
                    <button class="tournament-btn" onclick="startTournamentLobby()">
                        ‚ö° Create & Join Tournament
                    </button>

                    <div style="margin-top: 24px;">
                        <p style="margin-bottom: 8px; color: var(--c-text-muted); font-size: 0.95rem;">
                            Already have a lobby code?
                        </p>
                        <div style="display: flex; gap: 8px; justify-content: center; flex-wrap: wrap;">
                            <input id="joinLobbyCodeInput"
                                placeholder="Enter lobby code"
                                style="padding: 10px 14px; border-radius: 8px; border: 1px solid #ddd; min-width: 180px; text-transform: uppercase;">
                            <button class="tournament-btn" style="padding: 10px 18px; font-size: 0.95rem;"
                                    onclick="joinExistingLobby()">
                                üîë Join with code
                            </button>
                        </div>
                    </div>
                    
                    <div style="margin-top: 32px; padding: 20px; background: var(--c-surface-alt); border-radius: var(--radius-md);">
                        <h3>üìã How it works:</h3>

                        <ul style="text-align: left; max-width: 500px; margin: 16px auto; line-height: 1.8;">
                            <li>üéØ 2‚Äì4 players per tournament</li>
                            <li>‚è±Ô∏è Lobby starts in 3 minutes (or with 4 players)</li>
                            <li>üé® 3 minutes per round to draw</li>
                            <li>üèÖ With 3 players: top 2 go to the finals</li>
                            <li>üèÜ Winner enters the Hall of Fame</li>
                        </ul>
                    </div>
                </div>
                
                <div id="tournamentLobby" style="display:none;">
                    </div>
                
                <div id="tournamentDrawing" style="display:none;">
                    </div>
                
                <div id="tournamentResults" style="display:none;">
                    </div>
                <div id="tournamentHallOfFame" style="margin-top: 32px; display:none;">
                    <h3>üèÜ Tournament Hall of Fame</h3>
                    <div id="tournamentHallOfFameList"></div>
                </div>

            </div>
        </div>
    </div>
<div id="artModal" class="art-modal" onclick="closeModal()">
    <span class="close-modal">&times;</span>
    <img class="modal-content" id="modalImg" onclick="event.stopPropagation()">
    <div id="modalCaption" class="modal-caption"></div>
    <div style="text-align:center; margin-top: 10px;">
        <button class="btn-cta" id="downloadArtBtn" onclick="event.stopPropagation(); downloadCanvasImage();" style="padding: 10px 20px; font-size: 0.9rem; background: var(--c-accent-teal);">
            üíæ Download Tekening
        </button>
    </div>
</div>    <div id="toast" class="toast"></div>

    <script>
        // Initialiseer client global
        const SUPABASE_URL = "https://vxfzjzsshwxrqherfmfh.supabase.co";
        const SUPABASE_KEY = "sb_publishable_GOuAPSxNwfuzU1lxVxi4Dw_qN7kY-Xz";
        const client = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

        // --- TOURNAMENT LOBBY SYSTEM ---
        const LOBBY = {
            state: {
                tournamentId: null,
                playerId: null,
                playerName: '',
                checkInterval: null
            },
            
            // Genereer 6-letter code
            generateCode() {
                const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
                let code = '';
                for (let i = 0; i < 6; i++) {
                    code += chars[Math.floor(Math.random() * chars.length)];
                }
                return code;
            },
            
            // Start nieuw tournament
            async createNewLobby() {
                try {
                    const lobbyCode = this.generateCode();
                    const randomDog = Math.floor(Math.random() * CONFIG.dogs.length);
                    
                    console.log('Creating lobby:', lobbyCode);
                    
                    const { data: tournament, error } = await client
                        .from('tournaments')
                        .insert([{
                            lobby_code: lobbyCode,
                            reference_dog_id: randomDog,
                            max_players: 4,
                            draw_time_seconds: 180,
                            status: 'waiting'
                        }])
                        .select()
                        .single();
                    
                    if (error) throw error;
                    
                    this.state.tournamentId = tournament.id;
                    console.log('Lobby created:', tournament.id);
                    
                    return tournament;
                } catch (err) {
                    console.error('Error creating lobby:', err);
                    showToast('Error creating lobby', 'error');
                    return null;
                }
            },
            
            // Join tournament door speler toe te voegen
            async addPlayerToLobby(tournament, playerName) {
                try {
                    // Haal huidige spelers op
                    const { data: existingPlayers } = await client
                        .from('tournament_players')
                        .select('player_slot')
                        .eq('tournament_id', tournament.id);

                    // Bepaal volgende slot (0, 1, 2, 3)
                    let slot = 0;
                    if (existingPlayers && existingPlayers.length > 0) {
                        const usedSlots = existingPlayers.map(p => p.player_slot);
                        while (usedSlots.includes(slot)) {
                            slot++;
                        }
                    }

                    // Voeg speler toe, inclusief naam
                    const { data: player, error } = await client
                        .from('tournament_players')
                        .insert([{
                            tournament_id: tournament.id,
                            player_slot: slot,
                            is_eliminated: false,
                            current_round: 1,
                            player_name: playerName
                        }])
                        .select()
                        .single();

                    if (error) throw error;

                    this.state.playerId = player.id;
                    this.state.playerName = playerName;
                    console.log('Player added:', player.id);

                    return player;
                } catch (err) {
                    console.error('Error adding player:', err);
                    showToast('Error joining lobby', 'error');
                    return null;
                }
            },

            // Haal alle spelers in lobby op
            async getPlayersInLobby(tournamentId) {
                try {
                    const { data: players, error } = await client
                        .from('tournament_players')
                        .select('*')
                        .eq('tournament_id', tournamentId)
                        .order('player_slot');
                    
                    if (error) throw error;
                    return players || [];
                } catch (err) {
                    console.error('Error fetching players:', err);
                    return [];
                }
            },

            // Render the lobby waiting screen
            showLobbyUI(tournament, players) {
                const welcome = document.getElementById('tournamentWelcome');
                const lobby = document.getElementById('tournamentLobby');

                if (!welcome || !lobby) return;

                welcome.style.display = 'none';
                lobby.style.display = 'block';

               lobby.innerHTML = `
                    <div class="lobby-waiting">
                        <h1>üéÆ Waiting Lobby</h1>
                        <div class="lobby-code-display">
                            <p style="margin: 0 0 8px 0; color: var(--c-text-muted);">Lobby Code:</p>
                            <div class="code-big" style="font-size: 3rem; font-weight:800; letter-spacing: 5px; color: var(--c-primary);">${tournament.lobby_code}</div>
                        </div>

                        <div id="lobbyCountdown" class="countdown-display" style="margin-top:20px; background: #FEF3C7; padding: 15px; border-radius: 8px; border: 2px solid #F59E0B;">
                            <h3 style="color: #92400E; text-align:center;">
                                ‚è≥ Toernooi start over: <span id="lobbyCountdownSeconds">180</span>s
                            </h3>
                        </div>

                        <h3 style="text-align: center; margin: 16px 0;">
                            Spelers: <span id="playerCount">1</span>/4
                        </h3>
                        <div class="players-grid" id="playersGrid" style="display:flex; justify-content:center; gap:20px; margin-top:20px;"></div>

                        <p style="text-align: center; color: var(--c-text-muted); margin-top: 24px;">
                            Wacht op minimaal 2 spelers...
                        </p>
                    </div>
                `;

                this.updatePlayersGrid(players);
                this.startLobbyCountdown(tournament);
            },

            // Update the slots display
            updatePlayersGrid(players) {
                const grid = document.getElementById('playersGrid');
                const countEl = document.getElementById('playerCount');
                if (!grid || !countEl) return;

                const slots = [0, 1, 2, 3];
                grid.innerHTML = slots.map(slot => {
                    const player = players.find(p => p.player_slot === slot);
                    if (player) {
                        return `
                            <div class="player-slot filled" style="background:var(--c-surface); padding:15px; border-radius:8px; text-align:center; box-shadow:var(--shadow-sm);">
                                <div style="font-size: 2rem; margin-bottom: 8px;">üë§</div>
                                <div style="font-weight: 700;">${escapeHtml(player.player_name)}</div>
                                <div style="font-size: 0.85rem; margin-top: 4px;">Joined</div>
                            </div>
                        `;
                    } else {
                        return `
                            <div class="player-slot empty" style="background:var(--c-surface-alt); padding:15px; border-radius:8px; text-align:center; opacity:0.7;">
                                <div style="font-size: 2rem; margin-bottom: 8px; opacity: 0.3;">üë§</div>
                                <div style="font-weight: 600; color: var(--c-text-muted);">Waiting...</div>
                            </div>
                        `;
                    }
                }).join('');

                countEl.textContent = players.length.toString();
            },

            // Poll for other players joining the same lobby
            startLobbyPolling() {
                if (this.state.checkInterval) {
                    clearInterval(this.state.checkInterval);
                }

                this.state.checkInterval = setInterval(async () => {
                    if (!this.state.tournamentId) return;

                    const players = await this.getPlayersInLobby(this.state.tournamentId);
                    this.updatePlayersGrid(players);

                    // If 4 players: start immediately
                    if (players.length === 4) {
                        clearInterval(this.state.checkInterval);
                        this.state.checkInterval = null;
                        startTournamentFromLobby();
                    }
                }, 1500);
            },

            startLobbyCountdown(tournament) {
                const countdownEl = document.getElementById('lobbyCountdown');
                const secondsEl = document.getElementById('lobbyCountdownSeconds');
                if (!countdownEl || !secondsEl) return;

                countdownEl.style.display = 'block';
                let remaining = 180; // 3 minutes

                if (this.state.lobbyCountdownInterval) {
                    clearInterval(this.state.lobbyCountdownInterval);
                }

                this.state.lobbyCountdownInterval = setInterval(async () => {
                    remaining--;
                    if (remaining < 0) remaining = 0;
                    secondsEl.textContent = remaining.toString();

                    if (remaining <= 0) {
                        clearInterval(this.state.lobbyCountdownInterval);

                        if (!this.state.tournamentId) return;
                        const players = await this.getPlayersInLobby(this.state.tournamentId);

                        if (players.length >= 2) {
                            showToast('Lobby time over. Starting...', 'success');
                            startTournamentFromLobby();
                        } else {
                            showToast('Not enough players to start the tournament', 'error');
                        }
                    }
                }, 1000);
            }
        };

      // --- CONFIG & STATE ---
const CONFIG = {
    width: 600,
    height: 450,
    dogs: [
        { name: 'Dawg w the glasses', url: 'https://images.unsplash.com/photo-1554224311-beee415c201f?q=80&w=735&auto=format&fit=crop' },
        { name: 'Banana dog', url: 'https://images.unsplash.com/photo-1701445175220-1f485a27fb41?w=600&auto=format&fit=crop' },
        { name: 'Golden', url: 'https://images.unsplash.com/photo-1510771463146-e89e6e86560e?q=80&w=627&auto=format&fit=crop' },
        { name: 'Fluff', url: 'https://images.unsplash.com/photo-1505628346881-b72b27e84530?q=80&w=687&auto=format&fit=crop' },
        { name: 'Annoying shit', url: 'https://images.unsplash.com/photo-1583511655826-05700d52f4d9?q=80&w=688&auto=format&fit=crop' },
        { name: 'Murica', url: 'https://images.unsplash.com/photo-1422565096762-bdb997a56a84?q=80&w=1470&auto=format&fit=crop' }, // <--- Komma toegevoegd
        { name: 'BeachDawg', url: 'https://images.unsplash.com/photo-1530281700549-e82e7bf110d6?q=80&w=688&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D' }, // <--- Komma toegevoegd
        { name: 'The lovely Lab', url: 'https://images.unsplash.com/photo-1552053831-71594a27632d?q=80&w=662&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D' }, // <--- Komma toegevoegd
        { name: 'Grassy Dawg', url: 'https://images.unsplash.com/photo-1554456854-55a089fd4cb2?q=80&w=1170&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D' }, // <--- Komma toegevoegd
        { name: 'Why so serious?', url: 'https://images.unsplash.com/photo-1566710582818-d673dc761201?q=80&w=687&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D' } // Laatste regel heeft geen komma nodig (mag wel)
    ]
};

        const STATE = {
            drawings: [],
            myVotes: new Set(),
            tool: 'pen',
            color: '#000000',
lineWidth: 3,
            isDrawing: false,
            history: [],
            historyStep: -1,
            refImage: null,
            lastPos: { x: 0, y: 0 }
        };

        // --- DOM ELEMENTS ---
        const canvas = document.getElementById('drawCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const refCanvas = document.getElementById('refCanvas');
        const refCtx = refCanvas.getContext('2d', { willReadFrequently: true });
        const overlayCanvas = document.getElementById('overlayCanvas');
        const overlayCtx = overlayCanvas.getContext('2d');

        // --- INITIALIZATION ---
        function init() {
            const storedDrawings = localStorage.getItem('hddc_drawings');
            const storedVotes = localStorage.getItem('hddc_votes');
            
            // Setup Canvas Defaults
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            saveHistory();

            // Populate Dropdown
            const select = document.getElementById('refSelect');
            if (select) {
                CONFIG.dogs.forEach((dog, i) => {
                    const opt = document.createElement('option');
                    opt.value = i;
                    opt.text = dog.name;
                    select.appendChild(opt);
                });
            }
            // Update Stats
            if (storedVotes) STATE.myVotes = new Set(JSON.parse(storedVotes));
        }

        // --- DRAWING LOGIC ---
        function getPos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX || e.touches[0].clientX) - rect.left;
            const y = (e.clientY || e.touches[0].clientY) - rect.top;
            return { x: x * scaleX, y: y * scaleY };
        }

        function startDraw(e) {
            if(e.type !== 'mousedown' && e.type !== 'touchstart') return;
            e.preventDefault();
            STATE.isDrawing = true;
            STATE.lastPos = getPos(e);
            
            if(STATE.tool === 'fill') {
                floodFill(Math.floor(STATE.lastPos.x), Math.floor(STATE.lastPos.y), STATE.color);
                STATE.isDrawing = false;
                saveHistory();
            }
        }

        function moveDraw(e) {
            if(!STATE.isDrawing) return;
            e.preventDefault();
            const pos = getPos(e);

            ctx.beginPath();
            ctx.moveTo(STATE.lastPos.x, STATE.lastPos.y);
            ctx.lineTo(pos.x, pos.y);
            
            ctx.strokeStyle = STATE.tool === 'eraser' ? '#FFFFFF' : STATE.color;
            // Als het de eraser is, maken we hem iets groter dan de pen voor gemak
            if (STATE.tool === 'eraser') {
                ctx.lineWidth = STATE.lineWidth * 2;
                ctx.strokeStyle = '#FFFFFF';
            } else {
                ctx.lineWidth = STATE.lineWidth;
                ctx.strokeStyle = STATE.color;
            }
            
            if(STATE.tool === 'eraser') ctx.strokeStyle = '#FFFFFF';

            ctx.stroke();
            STATE.lastPos = pos;
        }

        function endDraw() {
            if(STATE.isDrawing) {
                STATE.isDrawing = false;
                saveHistory();
            }
        }

        // --- FLOOD FILL ---
        function floodFill(x, y, hexColor) {
            const imgData = ctx.getImageData(0,0,canvas.width,canvas.height);
            const data = imgData.data;
            const targetColor = getPixel(data, x, y);
            const fillColor = hexToRgb(hexColor);
            
            if(colorsMatch(targetColor, fillColor)) return;

            const stack = [[x, y]];
            while(stack.length) {
                const [cx, cy] = stack.pop();
                if(cx < 0 || cx >= canvas.width || cy < 0 || cy >= canvas.height) continue;
                
                const current = getPixel(data, cx, cy);
                if(colorsMatch(current, targetColor)) {
                    setPixel(data, cx, cy, fillColor);
                    stack.push([cx+1, cy], [cx-1, cy], [cx, cy+1], [cx, cy-1]);
                }
            }
            ctx.putImageData(imgData, 0, 0);
        }
        
        function getPixel(data, x, y) {
            const i = (y * canvas.width + x) * 4;
            return {r: data[i], g: data[i+1], b: data[i+2]};
        }
        
        function setPixel(data, x, y, c) {
            const i = (y * canvas.width + x) * 4;
            data[i] = c.r; data[i+1] = c.g; data[i+2] = c.b; data[i+3] = 255;
        }
        
        function colorsMatch(c1, c2) {
            return Math.abs(c1.r - c2.r) < 10 && Math.abs(c1.g - c2.g) < 10 && Math.abs(c1.b - c2.b) < 10;
        }
        
        function hexToRgb(hex) {
            const r = parseInt(hex.substr(1,2), 16);
            const g = parseInt(hex.substr(3,2), 16);
            const b = parseInt(hex.substr(5,2), 16);
            return {r,g,b};
        }

        // --- HISTORY ---
        function saveHistory() {
            STATE.historyStep++;
            STATE.history = STATE.history.slice(0, STATE.historyStep);
            STATE.history.push(canvas.toDataURL());
            if(STATE.history.length > 10) { STATE.history.shift(); STATE.historyStep--; }
        }

        function undo() {
            if(STATE.historyStep > 0) {
                STATE.historyStep--;
                const img = new Image();
                img.src = STATE.history[STATE.historyStep];
                img.onload = () => {
                    ctx.clearRect(0,0,canvas.width,canvas.height);
                    ctx.drawImage(img,0,0);
                }
            }
        }

                            // --- VERBETERDE REFERENCE IMAGE LOGICA ---
const refSelectElement = document.getElementById('refSelect');
if (refSelectElement) {
    refSelectElement.addEventListener('change', function(e) {
        const val = e.target.value;
        
        // Als er geen selectie is, reset alles
        if(val === "") {
            STATE.refImage = null;
            refCtx.fillStyle = '#FFFFFF';
            refCtx.fillRect(0, 0, canvas.width, canvas.height);
            document.getElementById('toggleRef').disabled = true;
            document.getElementById('toggleRef').checked = false;
            document.getElementById('opacitySlider').disabled = true;
            updateOverlay();
            return;
        }

        const selectedIndex = parseInt(val);
        const dog = CONFIG.dogs[selectedIndex];
        
        if(!dog) return;
        
        const img = new Image();
        img.crossOrigin = "Anonymous"; // Voorkomt problemen met tekenen van externe foto's
        img.src = dog.url;
        
        img.onload = () => {
            STATE.refImage = img;
            
            // Bereken schaal om de hond netjes in het canvas te passen
            const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
            const w = img.width * scale;
            const h = img.height * scale;
            const x = (canvas.width - w) / 2;
            const y = (canvas.height - h) / 2;
            
            // Teken op de verborgen referentie canvas
            refCtx.fillStyle = '#FFFFFF';
            refCtx.fillRect(0, 0, canvas.width, canvas.height);
            refCtx.drawImage(img, x, y, w, h);
            
            // Activeer de controls
            const toggleRef = document.getElementById('toggleRef');
            const opacitySlider = document.getElementById('opacitySlider');
            
            toggleRef.disabled = false;
            toggleRef.checked = true; // Zet het vinkje automatisch aan
            opacitySlider.disabled = false;
            
            // Update de visuele overlay direct nadat de afbeelding op refCtx staat
            updateOverlay();
        };

        img.onerror = () => {
            console.error('Kon afbeelding niet laden:', dog.url);
            showToast('Kon voorbeeld-afbeelding niet laden.', 'error');
        };
    });
}



        function updateOverlay() {
            overlayCtx.clearRect(0,0,canvas.width, canvas.height);
            if(document.getElementById('toggleRef').checked && STATE.refImage) {
                const opacity = document.getElementById('opacitySlider').value / 100;
                overlayCtx.globalAlpha = opacity;
                overlayCtx.drawImage(refCanvas, 0, 0);
            }
        }

        // --- ACCURACY ALGO ---
        function calculateAccuracy() {
            if(!STATE.refImage) return { total: 0, color: 0, shape: 0 };

            const dData = ctx.getImageData(0,0,canvas.width,canvas.height).data;
            const rData = refCtx.getImageData(0,0,canvas.width,canvas.height).data;
            
            let matchColor = 0, matchShape = 0, totalContent = 0;

            for(let i=0; i<dData.length; i+=16) {
                const rR=rData[i], rG=rData[i+1], rB=rData[i+2];
                const dR=dData[i], dG=dData[i+1], dB=dData[i+2];

                const isRefContent = (rR < 250 || rG < 250 || rB < 250);
                const isDrawContent = (dR < 250 || dG < 250 || dB < 250);

                if(isRefContent) {
                    totalContent++;
                    if(isDrawContent) {
                        matchShape++;
                        const diff = Math.abs(rR-dR) + Math.abs(rG-dG) + Math.abs(rB-dB);
                        if(diff < 100) matchColor++;
                    }
                }
            }

            if(totalContent === 0) return { total: 0 };
            
            const shapeScore = (matchShape / totalContent) * 100;
            const colorScore = matchShape > 0 ? (matchColor / matchShape) * 100 : 0;
            const total = (shapeScore * 0.6) + (colorScore * 0.4);

            return {
                total: Math.round(total),
                shape: Math.round(shapeScore),
                color: Math.round(colorScore)
            };
        }

        // --- SUBMIT & VOTE ---
        function vote(id) {
            const drawing = STATE.drawings.find(d => d.id === id);
            
            if(!drawing) return;
            if(STATE.myVotes.has(id)) {
                showToast('You already voted for this!', 'error');
                return;
            }
            if(drawing.isLocal) {
                showToast('You cannot vote for your own art!', 'error');
                return;
            }

            // Execute Vote (local optimistic update, real one happens via Supabase usually)
            drawing.votes++;
            STATE.myVotes.add(id);
            saveData();
            showToast('Vote cast! ‚ù§Ô∏è', 'success');
            renderGallery(); 
            updateGlobalStats();
        }

        // --- RENDERING ---
        function renderGallery() {
            const grid = document.getElementById('galleryGrid');
            const sorted = [...STATE.drawings].sort((a, b) => {
                if (b.votes !== a.votes) return b.votes - a.votes;
                return b.timestamp - a.timestamp;
            });

            grid.innerHTML = sorted.map(d => {
                const isVoted = STATE.myVotes.has(d.id);
                const isOwn = d.isLocal === true;
                
                let btnClass = 'can-vote';
                let btnText = '‚ù§Ô∏è Vote';
                // BELANGRIJK: event.stopPropagation() zorgt dat de foto niet vergroot als je alleen wilt stemmen
                let btnAction = `onclick="event.stopPropagation(); vote(${d.id})"`;
                
                if (isOwn) {
                    btnClass = 'own-art';
                    btnText = 'üë§ Your Art';
                    btnAction = 'onclick="event.stopPropagation();"';
                } else if (isVoted) {
                    btnClass = 'voted';
                    btnText = '‚úÖ Voted';
                    btnAction = 'onclick="event.stopPropagation();"';
                }

                return `
                <div class="art-card" onclick="openModal('${d.image}', '${escapeHtml(d.artist)}')">
                    <img src="${d.image}" class="art-image" style="cursor: zoom-in;">
                    <div class="art-info">
                        <div class="art-title">${escapeHtml(d.artist)}</div>
                        <div class="art-meta">
                            <span>‚ù§Ô∏è ${d.votes}</span>
                            <span>Score: ${d.scores.total || 0}%</span>
                        </div>
                        <button class="vote-btn ${btnClass}" ${btnAction}>
                            ${btnText}
                        </button>
                    </div>
                </div>`;
            }).join('');
        }

        function renderLeaderboard() {
            const list = document.getElementById('leaderboardList');
            const sorted = [...STATE.drawings].sort((a, b) => b.votes - a.votes).slice(0, 10);
            
            if(sorted.length === 0) {
                list.innerHTML = '<div style="text-align:center; padding:20px;">No drawings yet. Be the first!</div>';
                return;
            }

            list.innerHTML = sorted.map((d, i) => `
                <div class="rank-row">
                    <div class="rank-num rank-${i+1}">${i+1}</div>
                    <img src="${d.image}" style="width: 50px; height: 50px; object-fit: cover; border-radius: 4px; border:1px solid #eee;">
                    <div style="margin-left: 15px; flex: 1;">
                        <div style="font-weight:700;">${escapeHtml(d.artist)}</div>
                        <div style="font-size:0.8rem; color:#666;">${d.votes} Votes</div>
                    </div>
                </div>
            `).join('');
        }

        function renderAccuracy() {
            const list = document.getElementById('accuracyList');
            const sorted = [...STATE.drawings]
                .filter(d => d.scores.total > 0)
                .sort((a, b) => b.scores.total - a.scores.total)
                .slice(0, 10);

            if(sorted.length === 0) {
                list.innerHTML = '<div style="text-align:center; padding:20px;">Use a reference photo to get a Smart Score!</div>';
                return;
            }

            list.innerHTML = sorted.map((d, i) => `
                <div class="rank-row">
                    <div class="rank-num rank-${i+1}">${i+1}</div>
                    <img src="${d.image}" style="width: 50px; height: 50px; object-fit: cover; border-radius: 4px; border:1px solid #eee;">
                    <div style="margin-left: 15px; flex: 1;">
                        <div style="font-weight:700;">${escapeHtml(d.artist)}</div>
                        <div style="font-size:0.8rem; color:#666;">
                            Total: <strong>${d.scores.total}%</strong> 
                            (Color: ${d.scores.color}% | Shape: ${d.scores.shape}%)
                        </div>
                    </div>
                </div>
            `).join('');
        }

        // --- UTILS & HELPERS ---
        async function startTournamentLobby() {
            try {
                // 1. Create lobby
                const tournament = await LOBBY.createNewLobby();
                if (!tournament) return;

                LOBBY.state.tournamentId = tournament.id;

                // 2. Add this player
                const nameInput = document.getElementById('artistName');
                const playerName = nameInput && nameInput.value.trim() ? nameInput.value.trim() : 'Anonymous';

                const player = await LOBBY.addPlayerToLobby(tournament, playerName);
                if (!player) return;

                // 3. Show lobby UI
                LOBBY.showLobbyUI(tournament, [player]);

                // 4. Start polling for other players
                LOBBY.startLobbyPolling();
            } catch (err) {
                console.error(err);
                showToast('Error starting tournament lobby', 'error');
            }
        }
       async function startTournamentFromLobby() {
            // STOP ALLE LOBBY TIMERS DIRECT (Voorkomt de herstart-glitch)
            if (LOBBY.state.checkInterval) { 
                clearInterval(LOBBY.state.checkInterval); 
                LOBBY.state.checkInterval = null; 
            }
            if (LOBBY.state.lobbyCountdownInterval) { 
                clearInterval(LOBBY.state.lobbyCountdownInterval); 
                LOBBY.state.lobbyCountdownInterval = null; 
            }
            
            const lobbyCountdown = document.getElementById('lobbyCountdown');
            if (lobbyCountdown) lobbyCountdown.style.display = 'none';

            try {
                if (!LOBBY.state.tournamentId) return;

                const players = await LOBBY.getPlayersInLobby(LOBBY.state.tournamentId);
                TOURNAMENT.players = players;

                const { data: tournament, error } = await client
                    .from('tournaments')
                    .select('id, status')
                    .eq('id', LOBBY.state.tournamentId)
                    .single();

                if (error || !tournament) {
                    showToast('Could not start tournament', 'error');
                    return;
                }

                const nowIso = new Date().toISOString();
                const { error: updateError } = await client
                    .from('tournaments')
                    .update({
                        status: 'active',
                        started_at: nowIso,
                        current_round: 1,
                        round_started_at: nowIso
                    })
                    .eq('id', LOBBY.state.tournamentId);

if (updateError) throw updateError;

                showToast('Tournament started!', 'success');
                beginTournamentRounds(); 
            } catch (err) {
                console.error(err);
                showToast('Error starting tournament', 'error');
            }
        }

        async function joinExistingLobby() {
            try {
                const input = document.getElementById('joinLobbyCodeInput');
                if (!input) return;

                const code = input.value.trim().toUpperCase();
                if (!code) {
                    showToast('Please enter a lobby code', 'error');
                    return;
                }

                // Find existing tournament with this code
                const { data: tournament, error } = await client
                    .from('tournaments')
                    .select('*')
                    .eq('lobby_code', code)
                    .eq('status', 'waiting')
                    .single();

                if (error || !tournament) {
                    console.error(error);
                    showToast('Lobby not found or already started', 'error');
                    return;
                }

                // Add this player
                const nameInput = document.getElementById('artistName');
                const playerName = nameInput && nameInput.value.trim() ? nameInput.value.trim() : 'Anonymous';

                const player = await LOBBY.addPlayerToLobby(tournament, playerName);
                if (!player) return;

                // Save state
                LOBBY.state.tournamentId = tournament.id;

                // Get all players and show lobby
                const players = await LOBBY.getPlayersInLobby(tournament.id);
                LOBBY.showLobbyUI(tournament, players);

                // Start polling
                LOBBY.startLobbyPolling();
            } catch (err) {
                console.error(err);
                showToast('Error joining lobby', 'error');
            }
        }
        
        function activateTab(tabId) {
            document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
            document.getElementById(tabId).classList.add('active');
            
            document.querySelectorAll('.nav-tab').forEach(el => el.classList.remove('active'));
            const index = ['draw', 'gallery', 'leaderboard', 'accuracy', 'tournament'].indexOf(tabId);
            if(index >= 0) document.querySelectorAll('.nav-tab')[index].classList.add('active');

            if(tabId === 'gallery') renderGallery();
            if(tabId === 'leaderboard') renderLeaderboard();
            if(tabId === 'accuracy') renderAccuracy();
            if (tabId === 'tournament') {
                console.log('Tournament tab opened!');
                loadTournamentHallOfFame();
            }
        }
function openModal(imgSrc, artistName) {
    const modal = document.getElementById('artModal');
    const modalImg = document.getElementById('modalImg');
    const captionText = document.getElementById('modalCaption');
    
    modal.style.display = "block";
    modalImg.src = imgSrc;
    captionText.innerHTML = "By: " + artistName;
    
    // Voorkom scrollen van de achtergrond
    document.body.style.overflow = 'hidden';
}

function closeModal() {
    document.getElementById('artModal').style.display = "none";
    document.body.style.overflow = 'auto';
}
        function saveData() {
            localStorage.setItem('hddc_drawings', JSON.stringify(STATE.drawings));
            localStorage.setItem('hddc_votes', JSON.stringify([...STATE.myVotes]));
            updateGlobalStats();
        }

        function updateGlobalStats() {
            document.getElementById('statTotalDrawings').textContent = STATE.drawings.length;
            const totalVotes = STATE.drawings.reduce((sum, d) => sum + d.votes, 0);
            document.getElementById('statTotalVotes').textContent = totalVotes;
        }

        function showToast(msg, type) {
            const t = document.getElementById('toast');
            t.textContent = msg;
            t.className = `toast show ${type}`;
            setTimeout(() => t.className = 'toast', 3000);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // --- EVENT BINDINGS (Short) ---
        ['mousedown', 'touchstart'].forEach(evt => canvas.addEventListener(evt, startDraw));
        ['mousemove', 'touchmove'].forEach(evt => canvas.addEventListener(evt, moveDraw));
        ['mouseup', 'touchend'].forEach(evt => window.addEventListener(evt, endDraw));
        
        document.getElementById('btnUndo').onclick = undo;
        document.getElementById('btnClear').onclick = () => { ctx.fillRect(0,0,canvas.width,canvas.height); saveHistory(); };
        
        // Tool Buttons
        const tools = { btnPen: 'pen', btnBrush: 'brush', btnEraser: 'eraser', btnFill: 'fill' };
        Object.keys(tools).forEach(id => {
            document.getElementById(id).onclick = (e) => {
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                document.getElementById(id).classList.add('active');
                STATE.tool = tools[id];
            };
        });

        document.getElementById('colorPicker').onchange = (e) => STATE.color = e.target.value;
document.getElementById('sizeSlider').oninput = (e) => STATE.lineWidth = e.target.value;
        document.getElementById('toggleRef').onchange = updateOverlay;
        document.getElementById('opacitySlider').oninput = updateOverlay;

        async function loadTournamentHallOfFame() {
            const container = document.getElementById('tournamentHallOfFame');
            const listEl = document.getElementById('tournamentHallOfFameList');
            if (!container || !listEl) return;

            const { data, error } = await client
                .from('tournament_winners')
                .select('*')
                .order('completed_at', { ascending: false })
                .limit(20);

            if (error) {
                console.error('Error loading tournament hall of fame', error);
                return;
            }

            if (!data || data.length === 0) {
                container.style.display = 'none';
                return;
            }

            container.style.display = 'block';
            listEl.innerHTML = data.map((w, index) => `
                <div class="rank-row">
                    <div class="rank-num ${index === 0 ? 'rank-1' : index === 1 ? 'rank-2' : index === 2 ? 'rank-3' : ''}">
                        ${index + 1}
                    </div>
                    <div>
                        <div style="font-weight:700;">${w.winner_name || 'Anonymous winner'}</div>
                        <div style="font-size:0.85rem; color: var(--c-text-muted);">
                            Players: ${w.player_count || '?'} ‚Ä¢ Score: ${w.final_score || '?'}
                        </div>
                    </div>
                </div>
            `).join('');
        }


        // ===== SIMPLE TOURNAMENT FLOW =====
        const TOURNAMENT_DRAW_TIME_SECONDS = 180;
        const TOURNAMENT = {
            currentRound: 0,
            totalRounds: 0,
            players: [],          
            finalists: [],        
            winner: null,
            roundTimerId: null,
            roundTimeLeft: TOURNAMENT_DRAW_TIME_SECONDS,
            referenceDogIndex: null
        };

        // NIEUWE FUNCTIE: Start de rondes
        function beginTournamentRounds() {
            TOURNAMENT.currentRound = 1;
            // Als er meer dan 2 spelers zijn, doen we 2 rondes, anders 1
            const pCount = TOURNAMENT.players.length || 2; 
            TOURNAMENT.totalRounds = pCount > 2 ? 2 : 1;
            
            showTournamentDrawingRound();
        }

        // Show drawing UI for the round
        function showTournamentDrawingRound() {
            const container = document.getElementById('tournamentDrawing');
            const welcome = document.getElementById('tournamentWelcome');
            const lobby = document.getElementById('tournamentLobby');
            const results = document.getElementById('tournamentResults');

            if (!container) return;

            if (welcome) welcome.style.display = 'none';
            if (lobby) lobby.style.display = 'none';
            if (results) results.style.display = 'none';

            container.style.display = 'block';

            TOURNAMENT.referenceDogIndex = Math.floor(Math.random() * CONFIG.dogs.length);
            const refDog = CONFIG.dogs[TOURNAMENT.referenceDogIndex];

            const refSelect = document.getElementById('refSelect');
            if (refSelect) {
                refSelect.value = TOURNAMENT.referenceDogIndex;
                const event = new Event('change');
                refSelect.dispatchEvent(event);
            }

            // Reset canvas
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            saveHistory();

            container.innerHTML = `
                <div class="drawing-card" style="align-items: stretch; max-width: 800px; margin: 0 auto;">
                    <h2 style="text-align:center; margin-bottom: 10px;">
                        ${buildTournamentRoundTitle()}
                    </h2>
                    <p style="text-align:center; color: var(--c-text-muted); margin-bottom: 10px;">
                        Reference: <strong>${refDog.name}</strong> ‚Äì You have 3 minutes to draw.
                    </p>
                    <p style="text-align:center; color: var(--c-text-muted); margin-bottom: 20px;">
                        Time left: <span id="tournamentRoundCountdown">180</span> seconds
                    </p>
                    <p style="text-align:center; color: var(--c-text-muted); margin-bottom: 20px;">
                        Use the normal drawing canvas in the "Draw" tab.
                    </p>
                </div>
            `;

            activateTab('draw');

            // Start countdown from server time
            loadTournamentState().then(state => {
                if (!state || !state.round_started_at) {
                    // Fallback als server tijd faalt
                    startTournamentCountdownFromTimestamp(new Date().toISOString(), TOURNAMENT_DRAW_TIME_SECONDS);
                    return;
                }
                const duration = state.draw_time_seconds || TOURNAMENT_DRAW_TIME_SECONDS;
                startTournamentCountdownFromTimestamp(state.round_started_at, duration);
            });
        }

        // NIEUWE FUNCTIE: Haal state op
        async function loadTournamentState() {
            try {
                const { data } = await client
                    .from('tournaments')
                    .select('*')
                    .eq('id', LOBBY.state.tournamentId)
                    .single();
                return data;
            } catch (e) { return null; }
        }

        // NIEUWE FUNCTIE: Timer logica
      function startTournamentCountdownFromTimestamp(startTimeIso, durationSeconds) {
            const countdownEl = document.getElementById('tournamentRoundCountdown');
            const statusHeader = document.getElementById('tournamentStatusHeader');
            const roundNameEl = document.getElementById('tournamentRoundName');
            const timeDisplayEl = document.getElementById('tournamentTimeDisplay');
            
            const startTime = new Date(startTimeIso).getTime();
            const endTime = startTime + (durationSeconds * 1000);

            if (TOURNAMENT.roundTimerId) clearInterval(TOURNAMENT.roundTimerId);

            // Toon de header op de tekenpagina
            if (statusHeader) statusHeader.style.display = 'block';
            if (roundNameEl) roundNameEl.textContent = TOURNAMENT.currentRound === 1 && TOURNAMENT.players.length > 2 ? 'Kwalificatie' : 'Finale';

            TOURNAMENT.roundTimerId = setInterval(() => {
                const now = Date.now();
                const leftMs = endTime - now;
                let leftSec = Math.ceil(leftMs / 1000);

                if (leftSec < 0) leftSec = 0;

                // Update beide timers (in de tab en in de header)
                if (countdownEl) countdownEl.textContent = leftSec;
                if (timeDisplayEl) {
                    const mins = Math.floor(leftSec / 60);
                    const secs = leftSec % 60;
                    timeDisplayEl.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
                }

                TOURNAMENT.roundTimeLeft = leftSec;

                if (leftSec <= 0) {
                    clearInterval(TOURNAMENT.roundTimerId);
                    if (statusHeader) statusHeader.style.display = 'none';
                    showToast('Tijd is om! Score wordt berekend...', 'info');
                    onTournamentRoundEnd();
                }
            }, 1000);
        }

        function buildTournamentRoundTitle() {
            const players = TOURNAMENT.players.length;
            if (players === 2) return 'Final Round';
            if (players > 2 && TOURNAMENT.currentRound === 1) return 'Knock-out Round';
            return 'Final Round';
        }

        // Called when 3 minutes of drawing are over
async function onTournamentRoundEnd() {
            // 1. Toon een grote melding over het hele scherm
            const overlay = document.createElement('div');
            overlay.id = "roundEndOverlay";
            overlay.style = "position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:9999; display:flex; flex-direction:column; align-items:center; justify-content:center; color:white; font-family:sans-serif;";
            overlay.innerHTML = `<h1 style="font-size:4rem; margin-bottom:20px; animation: bounce 0.5s infinite;">‚åõ TIJD IS OM!</h1><p style="font-size:1.5rem;">De jury beoordeelt je werk...</p>`;
            document.body.appendChild(overlay);

            // 2. Wacht 3 seconden en wissel dan pas naar de uitslag
            setTimeout(() => {
                const el = document.getElementById('roundEndOverlay');
                if(el) el.remove();
                activateTab('tournament');
            }, 3000);

            try {
                const scores = calculateAccuracy();                const totalScore = scores.total || 0;

                if (LOBBY.state.playerId && LOBBY.state.tournamentId) {
                    await client.from('tournament_rounds').insert([{
                        tournament_id: LOBBY.state.tournamentId,
                        player_id: LOBBY.state.playerId,
                        round_index: TOURNAMENT.currentRound,
                        total_score: totalScore,
                        color_score: scores.color || 0,
                        shape_score: scores.shape || 0,
                        reference_dog_index: TOURNAMENT.referenceDogIndex
                    }]);
                }

                await showTournamentResultsForCurrentRound();
            } catch (err) {
                console.error(err);
                showToast('Error saving tournament round score', 'error');
            }
        }

        async function showTournamentResultsForCurrentRound() {
            const container = document.getElementById('tournamentResults');
            const drawingView = document.getElementById('tournamentDrawing');
            
            if (!container) return;
            if (drawingView) drawingView.style.display = 'none';
            container.style.display = 'block';

            showToast('Resultaten ophalen...', 'info');
            // Wacht 4 seconden zodat iedereen de kans heeft om te uploaden
            await new Promise(r => setTimeout(r, 4000));

            const { data: roundScores, error } = await client
                .from('tournament_rounds')
                .select('*, tournament_players(player_name)')
                .eq('tournament_id', LOBBY.state.tournamentId)
                .eq('round_index', TOURNAMENT.currentRound);

            if (error) {
                showToast('Fout bij laden resultaten', 'error');
                return;
            }

            const entries = (roundScores || []).sort((a, b) => b.total_score - a.total_score);

            let html = `
                <div class="drawing-card" style="align-items: stretch; max-width: 800px; margin: 0 auto;">
                    <h2 style="text-align:center; margin-bottom: 8px;">
                        Tussenstand: ${TOURNAMENT.currentRound === 1 ? 'Kwalificatie' : 'Finale'}
                    </h2>
                    <p style="text-align:center; color:var(--c-text-muted); margin-bottom: 20px;">
                        Gedetailleerd overzicht van de jury-scores
                    </p>
                    
                    <div style="overflow-x: auto;">
                        <table style="width:100%; border-collapse: collapse; text-align: left;">
                            <thead>
                                <tr style="border-bottom: 2px solid var(--c-surface-alt); color: var(--c-text-muted); font-size: 0.85rem;">
                                    <th style="padding: 12px 8px;">#</th>
                                    <th style="padding: 12px 8px;">SPELER</th>
                                    <th style="padding: 12px 8px;">VORM</th>
                                    <th style="padding: 12px 8px;">KLEUR</th>
                                    <th style="padding: 12px 8px;">TOTAAL</th>
                                    <th style="padding: 12px 8px;">STATUS</th>
                                </tr>
                            </thead>
                            <tbody>
            `;

            entries.forEach((entry, index) => {
                const isMe = entry.player_id === LOBBY.state.playerId;
                const playerName = entry.tournament_players?.player_name || 'Anoniem';
                
                let statusBadge = "";
                if (TOURNAMENT.currentRound === 1 && TOURNAMENT.players.length > 2) {
                    statusBadge = index < 2 
                        ? '<span style="color:var(--c-accent-teal); font-weight:bold;">‚úÖ FINALIST</span>' 
                        : '<span style="color:var(--c-accent-rose);">‚ùå AFGEVALLEN</span>';
                } else {
                    statusBadge = index === 0 ? 'üèÜ WINNAAR' : 'ü•à 2e PLEK';
                }

                html += `
                    <tr style="border-bottom: 1px solid var(--c-surface-alt); ${isMe ? 'background:#FFF7ED; font-weight:bold;' : ''}">
                        <td style="padding: 12px 8px;">${index + 1}</td>
                        <td style="padding: 12px 8px;">${escapeHtml(playerName)} ${isMe ? '(Jij)' : ''}</td>
                        <td style="padding: 12px 8px;">${entry.shape_score}%</td>
                        <td style="padding: 12px 8px;">${entry.color_score}%</td>
                        <td style="padding: 12px 8px; font-size: 1.1rem; color: var(--c-primary);">${entry.total_score.toFixed(0)}</td>
                        <td style="padding: 12px 8px; font-size: 0.8rem;">${statusBadge}</td>
                    </tr>
                `;
            });

           html += `
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
            
            container.innerHTML = html;

            if (TOURNAMENT.currentRound < TOURNAMENT.totalRounds) {
                setTimeout(() => {
                    TOURNAMENT.currentRound++;
                    showTournamentDrawingRound();
                }, 8000);
            } else {
                setTimeout(() => {
                    determineTournamentWinner();
                }, 4000);
            }
        }
                 
    
     async function determineTournamentWinner() {
            try {
                const container = document.getElementById('tournamentResults');
                if (!container) return;

                const { data: allRounds, error } = await client
                    .from('tournament_rounds')
                    .select('*, tournament_players(player_name)')
                    .eq('tournament_id', LOBBY.state.tournamentId);

                if (error || !allRounds) return;

                const totals = {};
                allRounds.forEach(r => {
                    const pid = r.player_id;
                    if (!totals[pid]) {
                        totals[pid] = { name: r.tournament_players?.player_name || 'Onbekend', score: 0, id: pid };
                    }
                    totals[pid].score += r.total_score;
                });

                const scoreboard = Object.values(totals).sort((a, b) => b.score - a.score);
                const winner = scoreboard[0];
                
                // --- FIX: Vraag om naam als deze leeg is voor de Hall of Fame ---
                let finalName = document.getElementById('artistName').value.trim();
                if (LOBBY.state.playerId === winner.id && (!finalName || finalName === 'Anonymous')) {
                    const promptedName = prompt("üèÜ GEFELICITEERD! Je hebt gewonnen! Vul je naam in voor de Hall of Fame:", "");
                    finalName = promptedName ? promptedName.trim() : "Anonieme Legende";
                    document.getElementById('artistName').value = finalName;
                } else {
                    finalName = winner.name;
                }

                const card = container.querySelector('.drawing-card');
                card.innerHTML = `
                    <div style="text-align:center; padding:20px;">
                        <div style="font-size: 4rem;">üèÜ</div>
                        <h2 style="color:var(--c-primary);">TOERNOOI WINNAAR</h2>
                        <h1 style="font-size: 3rem; margin: 10px 0;">${escapeHtml(finalName)}</h1>
                        <p style="font-size: 1.2rem;">Eindscore: <strong>${winner.score.toFixed(0)}</strong> punten</p>
                        <hr style="margin: 20px 0; opacity: 0.2;">
                        <button class="btn-cta" onclick="location.reload()">Verlaat Toernooi</button>
                    </div>
                `;

                if (LOBBY.state.playerId === winner.id) {
                    await client.from('tournament_winners').insert([{
                        tournament_id: LOBBY.state.tournamentId,
                        winner_name: finalName,
                        final_score: winner.score,
                        player_count: scoreboard.length
                    }]);
                    showToast('Je staat in de Hall of Fame! üêæ', 'success');
                }

            } catch (err) {
                console.error("Fout bij bepalen winnaar:", err);
            }
        }

        // START

// --- DOWNLOAD FUNCTIE VOOR DE MODAL ---
function downloadCanvasImage() {
    const img = document.getElementById('modalImg');
    if (!img || !img.src) {
        showToast('Geen afbeelding gevonden om te downloaden', 'error');
        return;
    }
    
    const link = document.createElement('a');
    link.download = 'honden-kunstwerk.png';
    link.href = img.src;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    showToast('Tekening wordt gedownload...', 'success');
}
        init();

        // Load drawings from Supabase when page loads
        window.addEventListener('load', async function() {
            await loadDrawingsFromSupabase();
            document.getElementById('btnSubmit').addEventListener('click', publishDrawingToSupabase);
        });

        async function publishDrawingToSupabase() {
            const titleInput = document.getElementById('dogTitle');
            const artistInput = document.getElementById('artistName');

            const title = titleInput.value.trim();
            const artist = artistInput.value.trim();
            const imageData = canvas.toDataURL();
            const scores = calculateAccuracy();

            if (!title || !artist) {
                alert('Please fill in title and artist name!');
                return;
            }

            try {
                const { data, error } = await client
                .from('drawings')
                .insert([{ 
                    title: title, 
                    artist_name: artist, 
                    image_data: imageData,
                    scores: scores,
                    votes: 0 
                }]);

                if (error) throw error;

                showToast('Drawing published to Supabase! üéâ', 'success');
                titleInput.value = '';
                artistInput.value = '';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                STATE.history = [];
                STATE.historyStep = -1;

                await loadDrawingsFromSupabase();
                renderGallery();
            } catch (err) {
                console.error('Error publishing:', err);
                showToast('Error saving to Supabase!', 'error');
            }
        }

        async function loadDrawingsFromSupabase() {
            try {
                const { data, error } = await client
                .from('drawings')
                .select('*')
                .order('votes', { ascending: false });

                if (error) throw error;

                STATE.drawings = data.map(d => ({
                    id: d.id,
                    artist: d.artist_name,
                    image: d.image_data,
                    votes: d.votes,
                    scores: d.scores || { total: 0, color: 0, shape: 0 },
                    timestamp: new Date(d.created_at).getTime(),
                    isLocal: false
                }));

                console.log('Loaded', STATE.drawings.length, 'drawings from Supabase');
            } catch (err) {
                console.error('Error loading drawings:', err);
            }
        }
    </script>
</body>
</html>
