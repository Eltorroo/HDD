<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hand Drawn Dog | The Modern Sketchbook</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&family=Space+Grotesk:wght@400;600;700&display=swap" rel="stylesheet">
    
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>

    <style>
        /* --- 1. DESIGN SYSTEM: NEUBRUTALISM --- */
        :root {
            --bg-color: #F9F7F2;
            --text-color: #18181b;
            --white: #FFFFFF;
            --accent-yellow: #FCD34D;
            --accent-blue: #818CF8;
            --accent-green: #34D399;
            --accent-red: #F87171;
            
            --border: 3px solid var(--text-color);
            --shadow: 4px 4px 0px var(--text-color);
            --radius: 12px;
            
            --font-head: 'Fredoka', sans-serif;
            --font-body: 'Space Grotesk', sans-serif;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background-color: var(--bg-color);
            background-image: radial-gradient(var(--text-color) 1px, transparent 1px);
            background-size: 20px 20px;
            color: var(--text-color);
            font-family: var(--font-body);
            min-height: 100vh;
            padding: 20px 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            overscroll-behavior-y: none; /* Prevent refresh on pull */
        }

        h1, h2, h3 { font-family: var(--font-head); font-weight: 700; }
        
        /* --- UI COMPONENTS --- */
        .neu-box {
            background: var(--white);
            border: var(--border);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            padding: 20px;
            margin-bottom: 20px;
        }

        .neu-btn {
            background: var(--white);
            border: var(--border);
            border-radius: 8px;
            padding: 10px 20px;
            font-family: var(--font-head);
            font-weight: 600;
            cursor: pointer;
            box-shadow: 2px 2px 0px var(--text-color);
            transition: all 0.1s;
            text-transform: uppercase;
        }
        
        .neu-btn:active {
            transform: translate(2px, 2px);
            box-shadow: 0px 0px 0px var(--text-color);
        }

        .btn-blue { background: var(--accent-blue); color: white; }
        .btn-green { background: var(--accent-green); }
        .btn-red { background: var(--accent-red); color: white; }

.btn-x { 
            background: #000000 !important; 
            color: white !important; 
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .form-control {
            width: 100%;
            padding: 12px;
            border: var(--border);
            border-radius: 8px;
            font-family: var(--font-body);
            font-size: 1rem;
            background: var(--white);
            margin-bottom: 10px;
            box-shadow: 2px 2px 0px rgba(0,0,0,0.1);
        }

        /* --- LAYOUT --- */
        .app-container {
            width: 100%;
            max-width: 650px;
            margin: 0 auto;
        }

        /* --- HEADER --- */
        header {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
            background: var(--white);
            padding: 15px;
            border: var(--border);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
        }
        .logo { font-size: 1.5rem; display: flex; align-items: center; gap: 10px; }

        /* Contract Address Box */
        .ca-box {
            background: var(--accent-yellow);
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            gap: 5px;
        }
        .ca-text-display { 
            font-family: monospace; 
            font-size: 0.9rem; 
            word-break: break-all;
            background: rgba(255,255,255,0.5);
            padding: 5px;
            border-radius: 4px;
            border: 1px dashed black;
        }

        /* --- TABS --- */
        .nav-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: -3px;
            z-index: 10;
            position: relative;
            padding: 0 5px;
            overflow-x: auto;
        }

        .nav-tab {
            flex: 1;
            padding: 12px 5px;
            border: var(--border);
            border-bottom: none;
            border-radius: 12px 12px 0 0;
            background: #eee;
            font-family: var(--font-head);
            font-weight: 700;
            cursor: pointer;
            transition: 0.2s;
            white-space: nowrap;
            font-size: 0.9rem;
        }

        .nav-tab.active {
            background: var(--white);
            padding-bottom: 15px;
            margin-top: -8px;
            box-shadow: 0px -2px 0px rgba(0,0,0,0.05);
        }

        /* Tournament Tab Special Style */
        .nav-tab.tournament-tab {
            background: var(--accent-yellow);
        }
        .nav-tab.tournament-tab.active {
            background: var(--accent-yellow);
        }

        .tab-content-wrapper {
            background: var(--white);
            border: var(--border);
            border-radius: 0 0 var(--radius) var(--radius);
            box-shadow: var(--shadow);
            padding: 20px;
            min-height: 500px;
            z-index: 5;
            position: relative;
        }

        /* --- TAB LOGIC --- */
        .tab-pane { display: none; }
        .tab-pane.active { display: block; animation: fadeIn 0.3s; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

        /* --- TOOLBAR --- */
        .toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            background: #f4f4f5;
            padding: 10px;
            border: 2px dashed #ccc;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .tool-btn {
            width: 42px; height: 42px;
            border: 2px solid var(--text-color);
            border-radius: 50%;
            background: var(--white);
            font-size: 1.2rem;
            cursor: pointer;
            display: grid; place-items: center;
        }
        .tool-btn.active { background: var(--accent-blue); color: white; transform: scale(1.1); }

        .canvas-wrapper {
            position: relative;
            width: 100%;
            aspect-ratio: 4/3;
            border: var(--border);
            background: white;
            
            /* DEZE REGELS ZIJN NIEUW: */
            background-size: cover;
            background-position: center;
            /* ----------------------- */

            margin-bottom: 15px;
            touch-action: none;
            overflow: hidden;
            border-radius: 8px;
        }
        
        .canvas-wrapper canvas {
            width: 100% !important;
            height: 100% !important;
            position: absolute; top: 0; left: 0;
            touch-action: none;
        }

        /* --- GALLERY --- */
        .gallery-grid {
            display: grid;
            /* Aangepast naar 160px zodat de knoppen passen */
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 15px;
        }

        .art-card {
            border: 2px solid var(--text-color);
            border-radius: 8px;
            overflow: visible; /* Changed for crown */
            background: white;
            box-shadow: 3px 3px 0px rgba(0,0,0,0.1);
            transition: transform 0.2s;
            position: relative;
            display: flex;
            flex-direction: column;
        }
        .art-card:hover { transform: translateY(-3px); box-shadow: 4px 4px 0px var(--text-color); }
        .art-image { width: 100%; aspect-ratio: 4/3; object-fit: contain; border-bottom: 2px solid var(--text-color); background: white;}
        .art-info { padding: 8px; }
        
        .crown-badge {
            position: absolute; top: -10px; right: -5px;
            background: var(--accent-yellow); border: 2px solid black;
            padding: 2px 6px; font-size: 0.7rem; font-weight: bold;
            border-radius: 10px; z-index: 2;
            transform: rotate(5deg);
        }

        /* --- STATS --- */
        .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px; }
        .stat-card {
            background: var(--accent-blue); color: white;
            border: var(--border); border-radius: var(--radius);
            padding: 15px; text-align: center;
        }
        .stat-val { font-size: 2rem; font-weight: 700; text-shadow: 2px 2px 0px black; }

        .rank-row { display: flex; align-items: center; padding: 10px; border-bottom: 2px dashed #eee; }
        .rank-num { font-weight: 800; width: 30px; }

        /* --- MODAL & TOAST --- */
        .art-modal {
            display: none; position: fixed; z-index: 2000; left: 0; top: 0; width: 100%; height: 100%;
            background-color: rgba(24, 24, 27, 0.9); backdrop-filter: blur(5px);
        }
        .modal-content {
            margin: 5% auto; display: block; max-width: 90%; border: 4px solid white; border-radius: 12px;
        }
        .close-modal { position: absolute; top: 20px; right: 30px; color: white; font-size: 40px; cursor: pointer; }
        
        #toast {
            position: fixed; bottom: 20px; right: 20px;
            background: var(--text-color); color: white; padding: 15px;
            border-radius: 8px; border-left: 5px solid var(--accent-green);
            opacity: 0; transition: 0.3s; pointer-events: none; z-index: 3000;
        }
        #toast.show { opacity: 1; transform: translateY(-10px); }
        #toast.error { border-left-color: var(--accent-red); }

        /* --- CHART --- */
        #dexscreener-embed { position: relative; width: 100%; height: 600px; border: var(--border); border-radius: var(--radius); overflow: hidden; }
        #dexscreener-embed iframe { position: absolute; width: 100%; height: 100%; top: 0; left: 0; border: 0; }

/* --- AI LOADER STYLES --- */
        .pencil-loader {
            position: relative;
            width: 100px;
            height: 50px;
            margin: 0 auto;
        }

        .pencil-icon {
            font-size: 3rem;
            position: absolute;
            top: 0;
            left: 0;
            animation: write 0.8s infinite alternate;
        }

        @keyframes write {
            0% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(20px, -5px) rotate(-10deg); }
            50% { transform: translate(40px, 0) rotate(0deg); }
            75% { transform: translate(60px, -5px) rotate(10deg); }
            100% { transform: translate(80px, 0) rotate(0deg); }
        }

        @keyframes blink {
            50% { opacity: 0.5; }
        }

    </style>
</head>
<body>

    <div class="app-container">
        
        <header>
            <div class="logo">         $HDD - Hand Drawn Dog</div>
        </header>

        <div class="neu-box ca-box">
            <span style="font-weight:bold; font-size: 0.8rem; text-transform: uppercase; letter-spacing: 1px;">Contract Address</span>
            
            <div id="ca-text" class="ca-text-display">6ZKCEQPT7hULSD4iU9j4UXUA5gDbtuNLM93sXQx6BAGS</div>
            
            <div style="display: flex; gap: 10px; margin-top: 8px; margin-bottom: 12px; justify-content: center; align-items: center;">
                <a href="https://x.com/HandDrawnDogSol?s=20" target="_blank" class="neu-btn" style="text-decoration: none; color: black; padding: 5px 12px; font-size: 1.2rem; line-height: 1;">
                    ùïè
                </a>

                <button class="neu-btn btn-green" onclick="copyContractAddress()" style="padding: 5px 15px; font-size: 0.8rem;">
                    üìã Copy
                </button>

                <a href="https://t.me/HDDogportal" target="_blank" class="neu-btn btn-blue" style="text-decoration: none; padding: 5px 12px; font-size: 1.2rem; line-height: 1;">
                    ‚úàÔ∏è
                </a>
            </div>

            <div id="statsWidget" style="width:100%; max-width: 90%; margin: 10px auto 0; padding: 10px; background: rgba(255,255,255,0.5); border: 2px solid black; border-radius: 6px; display:none;">
                
                <div style="margin-bottom: 12px;">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:2px; font-weight:bold; font-size:0.75rem;">
                        <span>üî•TOKENS BURNED (Gone)</span>
                        <span id="burnPercentDisplay">Loading...</span>
                    </div>
                    <div style="width:100%; height:8px; background:white; border:1px solid black; border-radius:4px; overflow:hidden;">
                        <div id="burnProgressBar" style="width:0%; height:100%; background: #EF4444; transition: width 1s ease-out;"></div>
                    </div>
                    <div id="burnTotalDisplay" style="text-align:right; font-size:0.65rem; font-family:monospace; opacity:0.7;">checking chain...</div>
                </div>

                <div>
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:2px; font-weight:bold; font-size:0.75rem;">
                        <span> üîíTOKENS LOCKED  </span>
                        <span id="liqPercentDisplay">Loading...</span>
                    </div>
                    <div style="width:100%; height:8px; background:white; border:1px solid black; border-radius:4px; overflow:hidden;">
                        <div id="liqProgressBar" style="width:0%; height:100%; background: #3B82F6; transition: width 1s ease-out;"></div>
                    </div>
                    <div id="liqTotalDisplay" style="text-align:right; font-size:0.65rem; font-family:monospace; opacity:0.7;">checking chain...</div>
                </div>

            </div>
        </div>

        <div class="nav-tabs">
            <button class="nav-tab active" onclick="activateTab('draw')">‚úèÔ∏è Draw</button>
            <button class="nav-tab" onclick="activateTab('gallery')">üñºÔ∏è Gallery</button>
            <button class="nav-tab" onclick="activateTab('daily')">üìÖ Daily</button>
            <button class="nav-tab" onclick="activateTab('stats')">üìä Stats</button>
            <button class="nav-tab tournament-tab" onclick="activateTab('tournament')">üèÜ Tourney</button>
            <button class="nav-tab" onclick="activateTab('chart')">üìà Chart</button>
            <button class="nav-tab" onclick="activateTab('ai-dawgs')">ü§ñ AI Dawgs</button>
        </div>

        <div class="tab-content-wrapper">

           <div id="draw" class="tab-pane active">
                <h2 id="drawTitle" style="text-align: center; margin-bottom: 15px;">Create Masterpiece</h2>
                
                <div id="drawingPromptBanner" style="display:none; background: #FEF3C7; padding:10px; border:2px solid black; border-radius:8px; margin-bottom:15px; text-align:center; font-weight:bold;">
                    Target: <span id="drawingPromptText">...</span>
                </div>

                <input type="text" id="dogTitle" class="form-control" placeholder="1. Name your artwork..." maxlength="50">
                <select id="refSelect" class="form-control">
                    <option value="">Choose Reference (Optional)...</option>
                </select>

                <div class="toolbar">
                    <button class="tool-btn active" id="btnPen" title="Pen">üñäÔ∏è</button>
                    <button class="tool-btn" id="btnBrush" title="Brush">üñåÔ∏è</button>
                    <button class="tool-btn" id="btnCalligraphy" title="Calligraphy">üñãÔ∏è</button>
                    <button class="tool-btn" id="btnFill" title="Fill">ü™£</button>
                    <button class="tool-btn" id="btnEraser" title="Eraser">üßπ</button>
                    <div style="width:1px; background:#ccc; margin:0 5px;"></div>
                    <input type="color" id="colorPicker" value="#000000" style="height:35px; border:none; background:none; cursor: pointer;">
                    <input type="range" id="sizeSlider" min="1" max="50" value="5" style="width: 80px;">
                    <div style="width:1px; background:#ccc; margin:0 5px;"></div>
                    <button class="tool-btn" id="btnUndo" title="Undo">‚Ü∂</button>
                    <button class="tool-btn" id="btnClear" title="Clear">üóëÔ∏è</button>
                </div>

                <div class="canvas-wrapper">
                    <div id="tournamentStatusHeader" style="display:none; position:absolute; top:0; width:100%; background:var(--accent-yellow); z-index:100; text-align:center; padding:5px; font-weight:bold; border-bottom: 2px solid black;">
                        üèÜ TOURNAMENT: <span id="tournamentRoundName">Round</span> - <span id="tournamentTimeDisplay">00:00</span>
                    </div>

                    <canvas id="refCanvas" width="600" height="450" style="display: none;"></canvas>
                    <canvas id="overlayCanvas" width="600" height="450" style="pointer-events: none; z-index: 10;"></canvas>
                    <canvas id="drawCanvas" width="600" height="450" style="z-index: 5;"></canvas>
                    
                    </div> <div id="replayControls" style="display:none; justify-content:center; align-items:center; flex-wrap:wrap; gap:10px; margin-bottom:15px; background:#f4f4f5; padding:10px; border-radius:8px; border:2px dashed #ccc;">
                    <span style="font-weight:bold; font-size:0.9rem;">Replay Speed:</span>
                    <button class="neu-btn" onclick="setReplaySpeed(0.5)" style="padding:5px 10px; font-size:0.8rem;">0.5x</button>
                    <button class="neu-btn" onclick="setReplaySpeed(1.0)" style="padding:5px 10px; font-size:0.8rem; background:var(--accent-yellow);">1x</button>
                    <button class="neu-btn" onclick="setReplaySpeed(5.0)" style="padding:5px 10px; font-size:0.8rem;">5x</button>
                    <button class="neu-btn" onclick="setReplaySpeed(20.0)" style="padding:5px 10px; font-size:0.8rem;">üöÄ Max</button>
                    
                    <div style="width:1px; height:20px; background:#ccc; margin:0 5px;"></div>
                    
                    <button class="neu-btn btn-green" onclick="downloadReplayVideo()" style="padding:5px 10px; font-size:0.8rem;">üìπ Save Video</button>
                </div>

               <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom: 15px; font-size: 0.8rem;">
                    <div>
                        <input type="checkbox" id="toggleRef" disabled> Overlay Ref
                        <input type="range" id="opacitySlider" min="0" max="100" value="30" disabled style="width:60px; vertical-align:middle;">
                    </div>
                </div>

                <select id="bgSelect" class="form-control" style="margin-bottom: 10px; border: 2px solid var(--accent-blue); font-weight: bold;">
                    <option value="">üè† Studio (White Background)</option>
                    <option value="snowy">üèîÔ∏è Snowy Mountain</option>
                    <option value="arena">üèüÔ∏è Pok√©mon Arena</option>
                    <option value="pyramid">üê´ Pyramid Dawg</option>
                    <option value="tajmahal">üïå The Dawg at Taj Mahal?</option>
                    <option value="husky">‚ùÑÔ∏è Husky‚Äôs Only</option>
                    <option value="desert">üåµ Desert</option>
                    <option value="beach">üèñÔ∏è Beach Lover</option>
                    <option value="paris">ü•ê Oui Oui</option>
                    <option value="adventure">üßó Mountain Adventure</option>
                </select>

                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
    <input type="text" id="artistName" class="form-control" placeholder="2. Artist Name" maxlength="30" style="margin-bottom: 0; flex-grow: 1;">

    <button id="btnSubmit" class="neu-btn btn-green" style="font-weight: 700;">PUBLISH</button>

    <button id="btnDownloadOnly" class="neu-btn btn-blue" style="font-weight: 700; display:none; flex-grow: 1;" onclick="downloadCurrentCanvas()">
        üíæ SAVE IMAGE
    </button>

    <button id="btnResetAI" class="neu-btn btn-red" style="font-weight: 700; display:none; background:#EF4444; color:white; flex-grow: 1;" onclick="document.getElementById('btnClear').click()">
        üóëÔ∏è CLEAR & DRAW
    </button>
</div>
            </div>

           <div id="gallery" class="tab-pane">
                <h2 style="text-align: center; margin-bottom: 15px;">Community Sketches</h2>
                <div id="galleryGrid" class="gallery-grid">
                    <p style="text-align:center; width:100%; color:#888;">Loading sketches...</p>
                </div>
            </div>

           <div id="daily" class="tab-pane">
                <div class="neu-box" style="text-align:center; background: #FEF3C7; border-color: #F59E0B;">
                    <h2 style="margin-bottom:10px;">üìÖ Daily Challenge</h2>
                    
                    <div style="display:flex; justify-content:center; align-items:center; gap:15px; margin-bottom:10px;">
                        <button class="neu-btn" onclick="changeDailyDay(-1)" style="padding:5px 12px; font-weight:bold;">‚óÄ</button>
                        <span id="dailyDateDisplay" style="font-weight:bold; font-family:monospace; font-size:1.1rem;">Loading...</span>
                        <button class="neu-btn" onclick="changeDailyDay(1)" style="padding:5px 12px; font-weight:bold;">‚ñ∂</button>
                    </div>

                    <p style="font-size: 0.9rem; color:#666; margin-bottom:5px;">Challenge Prompt:</p>
                    <h3 id="dailyPromptDisplay" style="font-size: 1.4rem; margin-bottom: 20px;">Loading...</h3>
                    
                    <div id="dailyActionArea"></div>
                </div>

                <div id="dailyGalleryLocked" style="text-align:center; padding: 40px; display:none;">
                    <div style="font-size: 3rem;">üîí</div>
                    <h3>Gallery Locked</h3>
                    <p>Draw today's prompt to unlock the gallery!</p>
                </div>

                <div id="dailyGallery" class="gallery-grid" style="display:none; margin-top:20px;"></div>
            </div>

            <div id="stats" class="tab-pane">
                <h2 style="text-align: center; margin-bottom: 15px;">Project Stats</h2>
                
                <div class="stats-grid">
                    <div class="stat-card">
                        <div id="statTotalDrawings" class="stat-val">0</div>
                        <div>Total Drawings</div>
                    </div>
                    <div class="stat-card" style="background: var(--accent-red);">
                        <div id="statTotalVotes" class="stat-val">0</div>
                        <div>Votes Cast</div>
                    </div>
                </div>

                <hr style="margin: 20px 0; border-top: 2px dashed #ccc;">

                <h3>üèÜ Hall of Fame</h3>
                <div id="leaderboardList" style="margin-bottom: 30px;"></div>

                <h3>üéØ Accuracy Leaders</h3>
                <div id="accuracyList"></div>
            </div>

            <div id="tournament" class="tab-pane">
                <div id="tournamentWelcome" style="text-align:center;">
                     <h2>üèÜ Tournament Mode</h2>
                     <p style="margin-bottom: 20px;">Enter your artist name to join a lobby.</p>
                     <input id="tournamentArtistName" class="form-control" placeholder="Your Name" style="text-align:center; margin: 10px 0; font-weight:bold;">
                     <button class="neu-btn btn-green" onclick="startTournamentLobby()" style="width:100%; margin-bottom: 10px;">‚ö° Start New</button>
                     
                     <div style="margin-top:20px; display:flex; gap:10px; justify-content:center;">
                        <input id="joinLobbyCodeInput" class="form-control" placeholder="Lobby Code" style="width:140px; text-align:center; text-transform:uppercase; margin-bottom:0;">
                        <button class="neu-btn" onclick="joinExistingLobby()">Join</button>
                     </div>
                </div>
                
                <div id="tournamentLobby" style="display:none; text-align:center;">
                   </div>
                
                <div id="tournamentDrawing" style="display:none;"></div>
                <div id="tournamentResults" style="display:none;"></div>
                
                <div id="tournamentHallOfFame" style="margin-top:30px;">
                    <h3>Tournament Winners</h3>
                    <div id="tournamentHallOfFameList"></div>
                </div>
            </div>

            <div id="chart" class="tab-pane">
                 <h2 style="text-align: center; margin-bottom: 15px;">Live Chart</h2>
                 
                 <div style="text-align: center; margin-bottom: 20px;">
                    <a href="https://jup.ag/swap/SOL-6ZKCEQPT7hULSD4iU9j4UXUA5gDbtuNLM93sXQx6BAGS" 
                       target="_blank" 
                       class="neu-btn btn-green" 
                       style="text-decoration: none; display: inline-block; font-size: 1rem;">
                       ü™ê Buy on Jupiter
                    </a>
                 </div>

                 <div id="dexscreener-embed">
                    <iframe 
                        src="https://dexscreener.com/solana/6ZKCEQPT7hULSD4iU9j4UXUA5gDbtuNLM93sXQx6BAGS?embed=1&theme=dark&trades=0&info=0" 
                        allow="clipboard-write" allowfullscreen>
                    </iframe>
                 </div>
            </div>

            <div id="ai-dawgs" class="tab-pane">
                <div class="neu-box" style="text-align:center; background: #E0E7FF; border-color: #4338ca;">
                    <h2 style="margin-bottom:15px;">ü§ñ AI GENERATOR</h2>
                    <p style="margin-bottom:20px;">Describe a scenario and let the AI Dawg sketch it for you.</p>

                    <input type="text" id="aiPromptInput" class="form-control" 
                           placeholder="e.g. A rich dog on a yacht smoking a cigar..." 
                           style="font-size: 1.1rem; padding: 15px; text-align:center; border: 3px solid #4338ca;">

                    <br><br>

                    <button class="neu-btn btn-blue" onclick="generateAIDawg()" 
                            style="font-size: 1.2rem; padding: 15px 30px; border-width: 3px; box-shadow: 6px 6px 0px #1e1b4b;">
                        WHO LET THE DOGS DRAW? üêï
                    </button>
                    
                    <div id="aiLoading" style="display:none; margin-top:30px;">
                        <div class="pencil-loader">
                            <div class="pencil-icon">‚úèÔ∏è</div>
                        </div>
                        <p style="font-weight:bold; margin-top:10px; animation: blink 1s infinite;">The Dawg is sketching...</p>
                    </div>
                </div>
            </div>

        </div> </div>
    
    <div id="toast"></div>

    <div id="artModal" class="art-modal" onclick="closeModal()">
        <span class="close-modal">&times;</span>
        <img class="modal-content" id="modalImg" onclick="event.stopPropagation()">
        <div id="modalCaption" style="text-align:center; color:white; font-family:var(--font-head); margin-top:10px;"></div>
        <div style="text-align:center; margin-top:10px;">
             <button class="neu-btn btn-green" onclick="event.stopPropagation(); downloadCanvasImage();">üíæ Download</button>
        </div>
    </div>

    <script>


// --- REPLAY & VIDEO EXPORT ENGINE (MP4 FIX) ---
        let currentReplaySpeed = 1.0;
        let mediaRecorder = null;
        let recordedChunks = [];
        let recordingMimeType = ''; // We onthouden welk type we gebruiken

        function setReplaySpeed(speed) {
            currentReplaySpeed = speed;
            showToast(`Speed set to ${speed}x`, 'info');
            
            // Update knopjes visueel
            const btns = document.querySelectorAll('#replayControls button');
            btns.forEach(b => {
                if(b.innerText.includes(speed + 'x')) b.style.background = 'var(--accent-yellow)';
                else if(!b.innerText.includes('Save')) b.style.background = 'white';
            });
        }

        function downloadReplayVideo() {
            const id = STATE.currentReplayId; 
            if(!id) { showToast("Start a replay first!", "error"); return; }
            startReplay(id, true); // true = opnemen
        }

       function startReplay(id, isRecording = false) {
            // Zoek de tekening
            let drawing = STATE.drawings.find(d => d.id === id);
            if (!drawing) drawing = STATE.dailyDrawings.find(d => d.id === id);
            
            if(!drawing || !drawing.replay_data || drawing.replay_data.length === 0) {
                showToast("No replay data found.", "error");
                return;
            }

            STATE.currentReplayId = id;
            activateTab('draw');
            
            // UI Reset
            STATE.isReplaying = true;
            const submitBtn = document.getElementById('btnSubmit');
            if(submitBtn) {
                submitBtn.disabled = true; 
                submitBtn.textContent = isRecording ? 'üî¥ Recording...' : 'üîí Replaying';
                submitBtn.style.opacity = '0.5';
            }
            canvas.style.pointerEvents = 'none'; 
            document.getElementById('replayControls').style.display = 'flex';

            // Canvas reset
            ctx.clearRect(0, 0, canvas.width, canvas.height); 
            
            // --- FIX VOOR ZWARTE VIDEO: MAAK ACHTERGROND WIT ---
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            // --------------------------------------------------

            const bgSelect = document.getElementById('bgSelect');
            if(bgSelect) bgSelect.value = ""; 

            // --- VIDEO RECORDING START (SLIMME MP4 CHECK) ---
            if(isRecording) {
                try {
                    const stream = canvas.captureStream(30); // 30 FPS
                    
                    if (MediaRecorder.isTypeSupported('video/mp4')) {
                        recordingMimeType = 'video/mp4';
                    } else if (MediaRecorder.isTypeSupported('video/mp4;codecs=h264')) {
                        recordingMimeType = 'video/mp4;codecs=h264';
                    } else {
                        recordingMimeType = 'video/webm';
                    }

                    console.log("Recording with:", recordingMimeType);

                    mediaRecorder = new MediaRecorder(stream, { mimeType: recordingMimeType });
                    recordedChunks = [];
                    mediaRecorder.ondataavailable = (e) => { if(e.data.size > 0) recordedChunks.push(e.data); };
                    mediaRecorder.onstop = exportVideoFile;
                    mediaRecorder.start();
                    showToast("üî¥ Recording started...", "info");
                } catch(e) {
                    console.error("Recording failed", e);
                    showToast("Video recording not supported on this device", "error");
                    isRecording = false;
                }
            }

            const data = drawing.replay_data;
            let i = 0;
            const baseInterval = 15; 

            function playNextFrame() {
                if (!STATE.isReplaying) {
                    if(mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
                    return;
                }

                let pointsToDraw = Math.max(1, Math.ceil(currentReplaySpeed));
                if(currentReplaySpeed < 1) pointsToDraw = 1; 

                for(let k=0; k < pointsToDraw; k++) {
                    if (i >= data.length) {
                        finishReplay(isRecording);
                        return;
                    }

                    const p = data[i];

                    if (p.tool === 'fill') {
                        floodFill(p.x, p.y, p.color);
                    } else {
                        // --- FIX VOOR GUM IN VIDEO ---
                        // In plaats van 'destination-out' (wat transparant/zwart maakt),
                        // tekenen we wit ('source-over' met #FFFFFF) als we aan het opnemen zijn of replayen.
                        ctx.globalCompositeOperation = 'source-over';
                        
                        if (p.tool === 'eraser') {
                            ctx.strokeStyle = '#FFFFFF'; // Gum = Witte verf
                        } else {
                            ctx.strokeStyle = p.color;
                        }
                        // -----------------------------

                        ctx.lineWidth = p.size;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';

                        if (p.isNew) {
                            ctx.beginPath();
                            ctx.moveTo(p.x, p.y);
                            ctx.lineTo(p.x, p.y); 
                            ctx.stroke();
                        } else {
                            let prevIndex = i - 1;
                            while(prevIndex >= 0 && data[prevIndex].tool === 'fill') { prevIndex--; }
                            
                            if(prevIndex >= 0) {
                                const prev = data[prevIndex];
                                ctx.beginPath();
                                ctx.moveTo(prev.x, prev.y);
                                ctx.lineTo(p.x, p.y);
                                ctx.stroke();
                            }
                        }
                    }
                    i++;
                }

                let delay = baseInterval;
                if (currentReplaySpeed < 1) delay = baseInterval / currentReplaySpeed; 
                setTimeout(playNextFrame, delay);
            }
            playNextFrame();
        }

        function finishReplay(wasRecording) {
            STATE.isReplaying = false;
            showToast("Replay finished! üé¨", "success");
            
            if(wasRecording && mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }

            const submitBtn = document.getElementById('btnSubmit');
            if(submitBtn) {
                submitBtn.disabled = false;
                submitBtn.textContent = 'PUBLISH';
                submitBtn.style.opacity = '1';
            }
            canvas.style.pointerEvents = 'auto';
        }

        function exportVideoFile() {
            // Bepaal de juiste extensie op basis van wat we gekozen hebben
            const isMp4 = recordingMimeType.includes('mp4');
            const extension = isMp4 ? 'mp4' : 'webm';
            const type = isMp4 ? 'video/mp4' : 'video/webm';

            const blob = new Blob(recordedChunks, { type: type });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            // Hier zorgen we voor de juiste bestandsnaam
            a.download = `hdd-masterpiece-${Date.now()}.${extension}`;
            document.body.appendChild(a);
           a.click();
            window.URL.revokeObjectURL(url);
            showToast(`Video saved as .${extension}! üíæ`, "success");
        }        
        
        // --- SHARE ON X (MET KOPIEER FUNCTIE) ---
        async function shareOnX(artist, score, imageUrl) {
            const text = `Check out this masterpiece! $HDD on Sol @HandDrawnDogSol üé®üê∂\n\nArtist: ${artist}\nAccuracy Score: ${score}%\n\n(I pasted my art below üëá)\n\nDraw your own dog here:`;
            const url = window.location.href; 
            
            // 1. Probeer de afbeelding te kopi√´ren naar het klembord
            try {
                showToast("‚ôªÔ∏è Copying image for X...", "info");
                const response = await fetch(imageUrl);
                const blob = await response.blob();
                
                await navigator.clipboard.write([
                    new ClipboardItem({
                        [blob.type]: blob
                    })
                ]);
                showToast("‚úÖ Image copied! Just paste it in X (Ctrl+V)", "success");
            } catch (err) {
                console.error("Clipboard failed:", err);
                // Als het niet lukt (bijv. op sommige mobiele browsers), geven we een andere melding
                showToast("Could not auto-copy image. Please save it manually.", "error");
            }

            // 2. Open Twitter na een korte pauze (zodat de gebruiker de toast ziet)
            setTimeout(() => {
                const twitterUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(url)}`;
                window.open(twitterUrl, '_blank');
            }, 1000);
        }        // --- UI HELPER: TABS ---
        window.activateTab = function(tabId) {
            // Reset Daily Mode
            if (tabId !== 'draw' && STATE.isDailyChallenge) {
                document.getElementById('drawTitle').textContent = "Create Masterpiece";
                document.getElementById('drawingPromptBanner').style.display = 'none';
                document.getElementById('bgSelect').disabled = false;
                document.getElementById('dogTitle').disabled = false;
                document.getElementById('dogTitle').value = "";
                STATE.isDailyChallenge = false;
            }

            if (tabId === 'daily') checkDailyStatus();

            // 1. Knoppen updaten
            document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
            
            const buttons = document.querySelectorAll('.nav-tab');
            let btnIndex = 0;
            
            // Dit moet matchen met de volgorde van de HTML knoppen hierboven!
            if(tabId === 'draw') btnIndex = 0;
            else if(tabId === 'gallery') btnIndex = 1;
            else if(tabId === 'daily') btnIndex = 2;
            else if(tabId === 'stats' || tabId === 'leaderboard') btnIndex = 3;
            else if(tabId === 'tournament') btnIndex = 4;
            else if(tabId === 'chart') btnIndex = 5;
            else if(tabId === 'ai-dawgs') btnIndex = 6; 
            
            if(buttons[btnIndex]) buttons[btnIndex].classList.add('active');

            // 2. Content verbergen & Tonen
            document.querySelectorAll('.tab-pane').forEach(c => c.classList.remove('active'));
            
            let targetId = tabId;
            if(tabId === 'leaderboard') targetId = 'stats';
            
            const target = document.getElementById(targetId);
            if(target) target.classList.add('active');

            // 3. Render functies
            if(tabId === 'gallery') renderGallery();
            if(tabId === 'stats') { renderLeaderboard(); renderAccuracy(); }
            if(tabId === 'tournament') loadTournamentHallOfFame();
        };
        // --- BACKEND LOGIC (Supabase & Drawing) ---
        const SUPABASE_URL = "https://vxfzjzsshwxrqherfmfh.supabase.co";
        const SUPABASE_KEY = "sb_publishable_GOuAPSxNwfuzU1lxVxi4Dw_qN7kY-Xz"; 
        const client = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

        
const CONFIG = {
            width: 600,
            height: 450,
            backgrounds: {
              snowy: 'https://i.imgur.com/xyjKB8y.jpeg',
                arena: 'https://i.imgur.com/SQN7Ynp.jpeg',
                pyramid: 'https://i.imgur.com/LswYR2j.jpeg',
                tajmahal: 'https://i.imgur.com/k7lMXFB.jpeg',
                husky: 'https://i.imgur.com/qNXdUFe.jpeg',
                desert: 'https://i.imgur.com/CHbwFof.jpeg',
                beach: 'https://i.imgur.com/VqgRlwS.jpeg',
                paris: 'https://i.imgur.com/27PPx5F.jpeg',
                adventure: 'https://i.imgur.com/ejYHOgV.jpeg'
            },
            
            dogs: [
                { name: 'Dawg w the glasses', url: 'https://images.unsplash.com/photo-1554224311-beee415c201f?q=80&w=735&auto=format&fit=crop' },
                { name: 'I don\'t know', url: 'https://i.imgur.com/HQLadRP.jpeg' },
                { name: 'Side eye', url: 'https://i.imgur.com/beATevY.jpeg' },
                { name: 'Banana dog', url: 'https://images.unsplash.com/photo-1701445175220-1f485a27fb41?w=600&auto=format&fit=crop' },
                { name: 'Me after a big night out', url: 'https://i.imgur.com/jMb90Nw.png' },
                { name: 'Fluff', url: 'https://images.unsplash.com/photo-1505628346881-b72b27e84530?q=80&w=687&auto=format&fit=crop' },
                { name: 'Thug', url: 'https://i.imgur.com/8hkxbUv.png' },
                { name: 'The German', url: 'https://i.imgur.com/G2946VY.jpeg' },
                { name: 'Annoying shit', url: 'https://images.unsplash.com/photo-1583511655826-05700d52f4d9?q=80&w=688&auto=format&fit=crop' },
                { name: 'Murica', url: 'https://images.unsplash.com/photo-1422565096762-bdb997a56a84?q=80&w=1470&auto=format&fit=crop' },
                { name: 'The mrs', url: 'https://i.imgur.com/ku6rbCA.jpeg' },
                { name: 'HDD sellers once we hit 10MM', url: 'https://i.imgur.com/il8TKhA.jpeg' },
                { name: 'Twister', url: 'https://i.imgur.com/vFWgo5M.jpeg' },
                { name: 'Why so serious?', url: 'https://images.unsplash.com/photo-1566710582818-d673dc761201?q=80&w=687&auto=format&fit=crop' }
            ]
        };
      // VOEG DE PROMPTS TOE AAN CONFIG (Boven STATE)
        CONFIG.prompts = [
            "Draw a fat dog eating a pizza",
            "Draw a dog as a superhero",
            "Draw a dog sleeping on the moon",
            "Draw a dog wearing a fancy suit",
            "Draw a robot dog",
            "Draw a dog playing poker",
            "Draw a giant dog in a tiny car",
            "Draw a dog surfing on a wave",
            "Draw a dog dressed as a pirate",
            "Draw a dog finding a treasure bone"
        ];

        const STATE = {
            drawings: [],
dailyDrawings: [],
            myVotes: new Set(),
            tool: 'pen',
            color: '#000000',
            baseLineWidth: 5,
            history: [],
            historyStep: -1,
            recordingHistory: [], 
            refImage: null,
            points: [],
            isDrawing: false,
            newStroke: false,
            isReplaying: false, 
            recording: [],
            // NIEUWE DAILY STATE:
            isDailyChallenge: false,
            currentDailyDate: null
        };

        const canvas = document.getElementById('drawCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const refCanvas = document.getElementById('refCanvas');
        const refCtx = refCanvas.getContext('2d', { willReadFrequently: true });
        const overlayCanvas = document.getElementById('overlayCanvas');
        const overlayCtx = overlayCanvas.getContext('2d');

        function init() {
            const storedVotes = localStorage.getItem('hddc_votes');
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            // HIER HEBBEN WE DE WITTE VERF WEGGEHAALD
            // We maken het canvas leeg (transparant) in plaats van wit
            ctx.clearRect(0, 0, canvas.width, canvas.height); 
            
            saveHistory();

            const select = document.getElementById('refSelect');
            if (select) {
                CONFIG.dogs.forEach((dog, i) => {
                    const opt = document.createElement('option');
                    opt.value = i;
                    opt.text = dog.name;
                    select.appendChild(opt);
                });
            }
            if (storedVotes) STATE.myVotes = new Set(JSON.parse(storedVotes));
        }

        // --- DRAWING ENGINE (IMPROVED FROM PRO VERSION) ---
        function getPointerPos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            let pressure = e.pressure;
            if (e.pointerType === 'mouse') pressure = 0.5;
            return { 
                x: (e.clientX - rect.left) * scaleX, 
                y: (e.clientY - rect.top) * scaleY,
                pressure: pressure
            };
        }

        let inputPoints = []; 

        canvas.addEventListener('pointerdown', (e) => {
            e.preventDefault(); 
            canvas.setPointerCapture(e.pointerId);
            STATE.isDrawing = true;
            STATE.newStroke = true; 
            const pos = getPointerPos(e);
            
            if(STATE.tool === 'fill') {
                // 1. Voer de fill uit
                floodFill(Math.floor(pos.x), Math.floor(pos.y), STATE.color);
                
                // 2. SLA DE FILL OP VOOR DE REPLAY!
                STATE.recording.push({
                    tool: 'fill',
                    x: Math.floor(pos.x),
                    y: Math.floor(pos.y),
                    color: STATE.color,
                    isNew: true
                });

                STATE.isDrawing = false;
                saveHistory();
                return;
            }
            inputPoints = [pos, pos, pos]; 
            STATE.points = [];
            STATE.points.push(pos);
            drawDot(pos);
        });

        canvas.addEventListener('pointermove', (e) => {
            if (!STATE.isDrawing) return;
            e.preventDefault();
            const rawPos = getPointerPos(e);
            inputPoints.push(rawPos);
            if(inputPoints.length > 4) inputPoints.shift();
            
            // Smoothening
            const smoothPos = getAveragePoint(inputPoints);
            smoothPos.pressure = rawPos.pressure; 
            STATE.points.push(smoothPos);
            
// Sla de beweging op voor de replay
            if(STATE.isDrawing) {
                STATE.recording.push({
                    x: smoothPos.x, 
                    y: smoothPos.y, 
                    color: STATE.color,
                    size: getLineWidth(rawPos.pressure),
                    tool: STATE.tool,
                    isNew: STATE.newStroke // Correcte check
                });
                // Zet de schakelaar direct weer uit na het eerste punt
                STATE.newStroke = false; 
            }

            if (STATE.points.length < 3) return;

            const p1 = STATE.points[STATE.points.length - 3];
            const p2 = STATE.points[STATE.points.length - 2];
            const p3 = STATE.points[STATE.points.length - 1];
            
            const mid1 = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
            const mid2 = { x: (p2.x + p3.x) / 2, y: (p2.y + p3.y) / 2 };

            ctx.beginPath();
            ctx.moveTo(mid1.x, mid1.y);
            ctx.quadraticCurveTo(p2.x, p2.y, mid2.x, mid2.y);

            const pressure = p2.pressure;
            const width = getLineWidth(pressure);
            ctx.lineWidth = width;
            
            let alpha = 1.0;
            if (STATE.tool === 'brush') {
                alpha = Math.min(1, 0.1 + pressure * 0.9);
            } else if (STATE.tool === 'eraser') {
                alpha = 1.0;
            }
            
            ctx.globalAlpha = alpha;
            if (STATE.tool === 'eraser') {
                ctx.globalCompositeOperation = 'destination-out';
            } else {
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = STATE.color;
            }
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.stroke();
        });

        canvas.addEventListener('pointerup', (e) => {
            if (STATE.isDrawing) {
                STATE.isDrawing = false;
                ctx.globalCompositeOperation = 'source-over';
                ctx.globalAlpha = 1.0; 
                saveHistory();
                inputPoints = [];
            }
        });

        function getAveragePoint(points) {
            let x = 0;
            let y = 0;
            for (let p of points) { x += p.x; y += p.y; }
            return { x: x / points.length, y: y / points.length };
        }
        
        function drawDot(pos) {
             if (STATE.tool === 'eraser') return;
             const width = getLineWidth(pos.pressure);
             ctx.fillStyle = STATE.color;
             ctx.globalAlpha = STATE.tool === 'brush' ? (0.1 + pos.pressure * 0.9) : 1.0;
             ctx.beginPath();
             ctx.arc(pos.x, pos.y, width/2, 0, Math.PI * 2);
             ctx.fill();
        }

        function getLineWidth(pressure) {
            const base = parseInt(STATE.baseLineWidth);
            if (STATE.tool === 'pen') return Math.max(1, base * (0.8 + pressure * 0.4));
            else if (STATE.tool === 'brush') return Math.max(1, base * (pressure * 2.5));
            else if (STATE.tool === 'calligraphy') return Math.max(1, base); 
            return base * 2; 
        }

        function floodFill(x, y, hexColor) {
            const imgData = ctx.getImageData(0,0,canvas.width,canvas.height);
            const data = imgData.data;
            const targetColor = getPixel(data, x, y);
            const fillColor = hexToRgb(hexColor);
            if(colorsMatch(targetColor, fillColor)) return;
            const stack = [[x, y]];
            let loops = 0;
            const maxLoops = canvas.width * canvas.height;
            while(stack.length && loops < maxLoops) {
                loops++;
                const [cx, cy] = stack.pop();
                if(cx < 0 || cx >= canvas.width || cy < 0 || cy >= canvas.height) continue;
                const current = getPixel(data, cx, cy);
                if(colorsMatch(current, targetColor)) {
                    setPixel(data, cx, cy, fillColor);
                    stack.push([cx+1, cy], [cx-1, cy], [cx, cy+1], [cx, cy-1]);
                }
            }
            ctx.putImageData(imgData, 0, 0);
        }
        
        function getPixel(data, x, y) {
            const i = (y * canvas.width + x) * 4;
            return {r: data[i], g: data[i+1], b: data[i+2]};
        }
        
        function setPixel(data, x, y, c) {
            const i = (y * canvas.width + x) * 4;
            data[i] = c.r; data[i+1] = c.g; data[i+2] = c.b; data[i+3] = 255;
        }
        
        function colorsMatch(c1, c2) {
            return Math.abs(c1.r - c2.r) < 30 && Math.abs(c1.g - c2.g) < 30 && Math.abs(c1.b - c2.b) < 30;
        }
        
        function hexToRgb(hex) {
            const r = parseInt(hex.substr(1,2), 16);
            const g = parseInt(hex.substr(3,2), 16);
            const b = parseInt(hex.substr(5,2), 16);
            return {r,g,b};
        }

        function saveHistory() {
            STATE.historyStep++;
            // We maken de geschiedenis schoon als je een nieuwe lijn trekt na een 'Undo'
            STATE.history = STATE.history.slice(0, STATE.historyStep);
            // We slaan nu de rauwe pixel-data op in plaats van een zware tekststring
            STATE.history.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
            // Maximaal 20 stappen onthouden om geheugen te besparen
            if(STATE.history.length > 20) { 
                STATE.history.shift(); 
                STATE.historyStep--; 
            }
        }

        function undo() {
            if(STATE.historyStep > 0) {
                STATE.historyStep--;
                // Plaats de vorige pixels direct terug op het canvas
                ctx.putImageData(STATE.history[STATE.historyStep], 0, 0);
            }
        }
        const refSelectElement = document.getElementById('refSelect');
        if (refSelectElement) {
            refSelectElement.addEventListener('change', function(e) {
                const val = e.target.value;
                if(val === "") {
                    STATE.refImage = null;
                    refCtx.fillStyle = '#FFFFFF';
                    refCtx.fillRect(0, 0, canvas.width, canvas.height);
                    document.getElementById('toggleRef').disabled = true;
                    document.getElementById('toggleRef').checked = false;
                    document.getElementById('opacitySlider').disabled = true;
                    updateOverlay();
                    return;
                }
                const selectedIndex = parseInt(val);
                const dog = CONFIG.dogs[selectedIndex];
                if(!dog) return;
                const img = new Image();
                img.crossOrigin = "Anonymous"; 
                img.src = dog.url;
                img.onload = () => {
                    STATE.refImage = img;
                    const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
                    const w = img.width * scale;
                    const h = img.height * scale;
                    const x = (canvas.width - w) / 2;
                    const y = (canvas.height - h) / 2;
                    refCtx.fillStyle = '#FFFFFF';
                    refCtx.fillRect(0, 0, canvas.width, canvas.height);
                    refCtx.drawImage(img, x, y, w, h);
                    const toggleRef = document.getElementById('toggleRef');
                    const opacitySlider = document.getElementById('opacitySlider');
                    toggleRef.disabled = false;
                    toggleRef.checked = true; 
                    opacitySlider.disabled = false;
                    updateOverlay();
                };
                img.onerror = () => {
                    showToast('Could not load reference image.', 'error');
                };
            });
        }

        function updateOverlay() {
            overlayCtx.clearRect(0,0,canvas.width, canvas.height);
            if(document.getElementById('toggleRef').checked && STATE.refImage) {
                const opacity = document.getElementById('opacitySlider').value / 100;
                overlayCtx.globalAlpha = opacity;
                overlayCtx.drawImage(refCanvas, 0, 0);
            }
        }

        function calculateAccuracy() {
            if(!STATE.refImage) return { total: 0, color: 0, shape: 0 };
            const dData = ctx.getImageData(0,0,canvas.width,canvas.height).data;
            const rData = refCtx.getImageData(0,0,canvas.width,canvas.height).data;
            let refPixels = 0;       
            let drawnInside = 0;     
            let drawnOutside = 0;    
            let colorMatch = 0;      
            for(let i=0; i<dData.length; i+=16) {
                const rR=rData[i], rG=rData[i+1], rB=rData[i+2]; 
                const dR=dData[i], dG=dData[i+1], dB=dData[i+2]; 
                const isRef = (rR < 250 || rG < 250 || rB < 250);
                const isDrawn = (dR < 250 || dG < 250 || dB < 250);
                if (isRef) {
                    refPixels++;
                    if (isDrawn) {
                        drawnInside++; 
                        const diff = Math.abs(rR-dR) + Math.abs(rG-dG) + Math.abs(rB-dB);
                        if (diff < 250) { colorMatch++; }
                    }
                } else {
                    if (isDrawn) { drawnOutside++; }
                }
            }
            if(refPixels === 0) return { total: 0, color: 0, shape: 0 };
            let shapeScore = (drawnInside / refPixels) * 100 * 1.25;
            const messiness = drawnOutside / refPixels; 
            const penalty = Math.min(20, messiness * 20);
            shapeScore -= penalty;
            let colorScore = 0;
            if (drawnInside > 0) {
                colorScore = (colorMatch / drawnInside) * 100;
            }
            shapeScore = Math.max(0, Math.min(100, shapeScore));
            colorScore = Math.max(0, Math.min(100, colorScore));
            const totalScore = (shapeScore * 0.6) + (colorScore * 0.4);
            return {
                total: Math.round(totalScore),
                shape: Math.round(shapeScore), 
                color: Math.round(colorScore)
            };
        }

        async function vote(id) {
            // 1. Zoek de tekening (in normale lijst OF daily lijst)
            let drawing = STATE.drawings.find(d => d.id === id);
            if (!drawing) {
                drawing = STATE.dailyDrawings.find(d => d.id === id);
            }

            if(!drawing) return;

            // 2. Check of je al gestemd hebt
            if(STATE.myVotes.has(id)) {
                showToast('You already voted for this!', 'error');
                return;
            }
            if(drawing.isLocal) {
                showToast('You cannot vote for your own art!', 'error');
                return;
            }

            // 3. OPTIMISTIC UI UPDATE (Direct op scherm tonen)
            drawing.votes++;
            STATE.myVotes.add(id);
            saveData(); // Lokaal opslaan
            
            // UI verversen zonder herladen
            if (drawing.is_daily) {
                const btn = document.querySelector(`#dailyGallery button[onclick*="vote(${id})"]`);
                if(btn) {
                    btn.className = 'neu-btn';
                    btn.innerText = '‚úÖ Voted';
                    const infoDiv = btn.parentElement.querySelector('div:nth-child(2)');
                    if(infoDiv) infoDiv.innerHTML = `‚ù§Ô∏è ${drawing.votes} | Score: ${drawing.scores?.total || 0}%`;
                }
            } else {
                renderGallery(); 
            }
            
            showToast('Vote cast! ‚ù§Ô∏è', 'success');
            updateGlobalStats();

            // 4. DE DATABASE FIX
            try {
                // BELANGRIJK: We gebruiken nu exact de naam 'row_id' zoals in de SQL
                const { error } = await client.rpc('increment_vote', { row_id: id });

                if (error) {
                    console.error("Supabase Vote Error:", error);
                    throw error; 
                }
            } catch (err) {
                console.error("Vote failed, reverting UI", err);
                // Als het mislukt, draaien we de wijziging terug
                drawing.votes--;
                STATE.myVotes.delete(id);
                
                // UI terugzetten
                if(drawing.is_daily) {
                     const btn = document.querySelector(`#dailyGallery button[onclick*="vote(${id})"]`);
                     if(btn) { btn.className = 'neu-btn btn-green'; btn.innerText = '‚ù§Ô∏è Vote'; }
                } else {
                    renderGallery(); 
                }
                showToast('Vote failed... check connection', 'error');
            }
        }

function renderGallery() {
            const grid = document.getElementById('galleryGrid');
            
            // Sorteer: Eerst op stemmen, dan op tijd (nieuwste eerst)
            const sorted = [...STATE.drawings].sort((a, b) => {
                if (b.votes !== a.votes) return b.votes - a.votes;
                return b.timestamp - a.timestamp;
            });

            grid.innerHTML = sorted.map(d => {
                const isVoted = STATE.myVotes.has(d.id);
                const isOwn = d.isLocal === true;
                const isTournamentWinner = d.scores && d.scores.isTournamentWinner === true;
                
                // Kroontje voor toernooi winnaars
                const crownHtml = isTournamentWinner ? `<div class="crown-badge">üëë Tournament Dawg</div>` : '';

                // Logica voor de Vote knop
                let btnClass = 'neu-btn btn-green'; 
                let btnText = '‚ù§Ô∏è Vote';
                let btnAction = `onclick="event.stopPropagation(); vote(${d.id})"`;
                
                if (isOwn) {
                    btnClass = 'neu-btn';
                    btnText = 'üë§ Your Art';
                    btnAction = 'onclick="event.stopPropagation();"';
                } else if (isVoted) {
                    btnClass = 'neu-btn';
                    btnText = '‚úÖ Voted';
                    btnAction = 'onclick="event.stopPropagation();"';
                }

                // VEILIG MAKEN VAN DATA (zodat quotes de boel niet breken)
                const safeArtist = escapeHtml(d.artist).replace(/'/g, "\\'");
                const safeImage = d.image;
                const score = d.scores.total || 0;

                return `
                <div class="art-card" onclick="openModal('${safeImage}', '${safeArtist}')">
                    ${crownHtml} 
                    <img src="${safeImage}" class="art-image" style="cursor: zoom-in;">
                    
                    <div class="art-info">
                        <div style="font-weight:700;">${escapeHtml(d.artist)}</div>
                        
                        <div style="display:flex; justify-content:space-between; margin-bottom:5px; font-size:0.8rem;">
                            <span>‚ù§Ô∏è ${d.votes}</span>
                            <span>Score: ${score}%</span>
                        </div>

                        <div style="display: flex; gap: 5px;">
                            <button class="${btnClass}" style="flex: 2; padding:5px; font-size:0.75rem;" ${btnAction}>
                                ${btnText}
                            </button>
                            
                            ${d.replay_data && d.replay_data.length > 0 ? `
                                <button class="neu-btn" style="flex: 1; padding:5px;" title="Watch Replay" onclick="event.stopPropagation(); startReplay(${d.id})">
                                    ‚ñ∂
                                </button>
                            ` : ''}

                            <button class="neu-btn btn-x" style="flex: 1; padding:5px;" onclick="event.stopPropagation(); shareOnX('${safeArtist}', ${score}, '${safeImage}')">
                                ùïè
                            </button>
                        </div>
                    </div>
                </div>`;
            }).join('');
        }

        function renderLeaderboard() {
            const list = document.getElementById('leaderboardList');
            const sorted = [...STATE.drawings].sort((a, b) => b.votes - a.votes).slice(0, 10);
            if(sorted.length === 0) {
                list.innerHTML = '<div style="text-align:center; padding:20px;">No drawings yet. Be the first!</div>';
                return;
            }
            list.innerHTML = sorted.map((d, i) => `
                <div class="rank-row">
                    <div class="rank-num rank-${i+1}">${i+1}</div>
                    <img src="${d.image}" style="width: 50px; height: 50px; object-fit: cover; border-radius: 4px; border:1px solid #eee;">
                    <div style="margin-left: 15px; flex: 1;">
                        <div style="font-weight:700;">${escapeHtml(d.artist)}</div>
                        <div style="font-size:0.8rem; color:#666;">${d.votes} Votes</div>
                    </div>
                </div>
            `).join('');
        }

        function renderAccuracy() {
            const list = document.getElementById('accuracyList');
            const sorted = [...STATE.drawings]
                .filter(d => d.scores.total > 0)
                .sort((a, b) => b.scores.total - a.scores.total)
                .slice(0, 10);

            if(sorted.length === 0) {
                list.innerHTML = '<div style="text-align:center; padding:20px;">Use a reference photo to get a Smart Score!</div>';
                return;
            }
            list.innerHTML = sorted.map((d, i) => `
                <div class="rank-row">
                    <div class="rank-num rank-${i+1}">${i+1}</div>
                    <img src="${d.image}" style="width: 50px; height: 50px; object-fit: cover; border-radius: 4px; border:1px solid #eee;">
                    <div style="margin-left: 15px; flex: 1;">
                        <div style="font-weight:700;">${escapeHtml(d.artist)}</div>
                        <div style="font-size:0.8rem; color:#666;">
                            Total: <strong>${d.scores.total}%</strong> 
                            (Color: ${d.scores.color}% | Shape: ${d.scores.shape}%)
                        </div>
                    </div>
                </div>
            `).join('');
        }

        // --- TOURNAMENT LOGIC (FIXED SYNC) ---
        const LOBBY = {
            state: { tournamentId: null, playerId: null, playerName: '', checkInterval: null },
            generateCode() {
                const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
                let code = '';
                for (let i = 0; i < 6; i++) { code += chars[Math.floor(Math.random() * chars.length)]; }
                return code;
            },
            async createNewLobby() {
                try {
                    const lobbyCode = this.generateCode();
                    const randomDog = Math.floor(Math.random() * CONFIG.dogs.length);
                    const { data: tournament, error } = await client
                        .from('tournaments')
                        .insert([{ lobby_code: lobbyCode, reference_dog_id: randomDog, max_players: 4, draw_time_seconds: 180, status: 'waiting' }])
                        .select().single();
                    if (error) throw error;
                    this.state.tournamentId = tournament.id;
                    return tournament;
                } catch (err) {
                    console.error('Error creating lobby:', err);
                    showToast('Error creating lobby', 'error');
                    return null;
                }
            },
            async addPlayerToLobby(tournament, playerName) {
                try {
                    const { data: existingPlayers } = await client.from('tournament_players').select('player_slot').eq('tournament_id', tournament.id);
                    let slot = 0;
                    if (existingPlayers && existingPlayers.length > 0) {
                        const usedSlots = existingPlayers.map(p => p.player_slot);
                        while (usedSlots.includes(slot)) { slot++; }
                    }
                    const { data: player, error } = await client
                        .from('tournament_players')
                        .insert([{ tournament_id: tournament.id, player_slot: slot, is_eliminated: false, current_round: 1, player_name: playerName }])
                        .select().single();
                    if (error) throw error;
                    this.state.playerId = player.id;
                    this.state.playerName = playerName;
                    return player;
                } catch (err) {
                    console.error('Error adding player:', err);
                    showToast('Error joining lobby', 'error');
                    return null;
                }
            },
            async getPlayersInLobby(tournamentId) {
                try {
                    const { data: players, error } = await client.from('tournament_players').select('*').eq('tournament_id', tournamentId).order('player_slot');
                    if (error) throw error;
                    return players || [];
                } catch (err) { return []; }
            },
            showLobbyUI(tournament, players) {
                const welcome = document.getElementById('tournamentWelcome');
                const lobby = document.getElementById('tournamentLobby');
                if (!welcome || !lobby) return;
                welcome.style.display = 'none';
                lobby.style.display = 'block';
                
                // Using Neubrutalist styles inside Lobby
                lobby.innerHTML = `
                    <div class="neu-box">
                        <h1>üéÆ Waiting Lobby</h1>
                        <div>
                            <p>Lobby Code:</p>
                            <div style="font-size: 3rem; font-weight:800; letter-spacing: 5px; color: var(--accent-blue);">${tournament.lobby_code}</div>
                        </div>
                        <div id="lobbyCountdown" style="margin-top:20px; background: #FEF3C7; padding: 15px; border-radius: 8px; border: 2px solid #F59E0B;">
                            <h3>‚è≥ Starts in: <span id="lobbyCountdownSeconds">180</span>s</h3>
                        </div>
                        <h3>Players: <span id="playerCount">1</span>/4</h3>
                        <div id="playersGrid" class="gallery-grid" style="margin-top:20px;"></div>
                        <p style="margin-top:10px;">Wait for a minimum of 2 dawgs...</p>
                    </div>`;
                this.updatePlayersGrid(players);
                this.startLobbyCountdown(tournament);
            },
            updatePlayersGrid(players) {
                const grid = document.getElementById('playersGrid');
                const countEl = document.getElementById('playerCount');
                if (!grid || !countEl) return;
                const slots = [0, 1, 2, 3];
                grid.innerHTML = slots.map(slot => {
                    const player = players.find(p => p.player_slot === slot);
                    if (player) {
                        return `<div style="background:var(--white); padding:15px; border:2px solid black; border-radius:8px; text-align:center;">
                                <div style="font-size: 2rem;">üë§</div>
                                <div>${escapeHtml(player.player_name)}</div>
                            </div>`;
                    } else {
                        return `<div style="background:#eee; padding:15px; border-radius:8px; text-align:center; opacity:0.7;">
                                <div style="font-size: 2rem;">üë§</div><div>Waiting...</div>
                            </div>`;
                    }
                }).join('');
                countEl.textContent = players.length.toString();
            },
            startLobbyPolling() {
                if (this.state.checkInterval) clearInterval(this.state.checkInterval);
                this.state.checkInterval = setInterval(async () => {
                    if (!this.state.tournamentId) return;
                    const players = await this.getPlayersInLobby(this.state.tournamentId);
                    this.updatePlayersGrid(players);
                    if (players.length === 4) {
                        clearInterval(this.state.checkInterval);
                        this.state.checkInterval = null;
                        startTournamentFromLobby();
                    }
                }, 1500);
            },
            startLobbyCountdown(tournament) {
                const secondsEl = document.getElementById('lobbyCountdownSeconds');
                if (!secondsEl) return;
                
                // SYNC FIX: Calculate target time based on SERVER creation time
                const startTime = new Date(tournament.created_at).getTime();
                const targetEndTime = startTime + (180 * 1000); 
                
                if (this.state.lobbyCountdownInterval) clearInterval(this.state.lobbyCountdownInterval);
                this.state.lobbyCountdownInterval = setInterval(async () => {
                    const now = Date.now();
                    let remaining = Math.ceil((targetEndTime - now) / 1000);
                    if (remaining < 0) remaining = 0;
                    secondsEl.textContent = remaining.toString();
                    if (remaining <= 0) {
                        clearInterval(this.state.lobbyCountdownInterval);
                        if (!this.state.tournamentId) return;
                        const players = await this.getPlayersInLobby(this.state.tournamentId);
                        if (players.length >= 2) {
                            showToast('Lobby time over. Starting...', 'success');
                            startTournamentFromLobby();
                        } else {
                            showToast('Not enough players to start', 'error');
                        }
                    }
                }, 1000);
            }
        };

        const TOURNAMENT_DRAW_TIME_SECONDS = 180;
        const TOURNAMENT = {
            currentRound: 0,
            totalRounds: 0,
            players: [],          
            finalists: [],        
            winner: null,
            roundTimerId: null,
            roundTimeLeft: TOURNAMENT_DRAW_TIME_SECONDS,
            referenceDogIndex: null
        };

        async function startTournamentLobby() {
            const nameInput = document.getElementById('tournamentArtistName');
            const playerName = nameInput ? nameInput.value.trim() : '';
            if (!playerName || playerName === '' || playerName === 'Anonymous') {
                showToast('Enter your dawg name', 'error');
                return;
            }
            LOBBY.state.playerName = playerName;
            document.getElementById('artistName').value = playerName;
            try {
                const tournament = await LOBBY.createNewLobby();
                if (!tournament) return;
                LOBBY.state.tournamentId = tournament.id;
                const player = await LOBBY.addPlayerToLobby(tournament, playerName);
                if (!player) return;
                LOBBY.showLobbyUI(tournament, [player]);
                LOBBY.startLobbyPolling();
            } catch (err) {
                console.error(err);
                showToast('Error starting tournament lobby', 'error');
            }
        }

        async function startTournamentFromLobby() {
            if (LOBBY.state.checkInterval) { clearInterval(LOBBY.state.checkInterval); LOBBY.state.checkInterval = null; }
            if (LOBBY.state.lobbyCountdownInterval) { clearInterval(LOBBY.state.lobbyCountdownInterval); LOBBY.state.lobbyCountdownInterval = null; }
            try {
                if (!LOBBY.state.tournamentId) return;
                const players = await LOBBY.getPlayersInLobby(LOBBY.state.tournamentId);
                TOURNAMENT.players = players;
                const { data: tournament, error } = await client.from('tournaments').select('id, status').eq('id', LOBBY.state.tournamentId).single();
                if (error || !tournament) { showToast('Could not start tournament', 'error'); return; }
                const nowIso = new Date().toISOString();
                const { error: updateError } = await client.from('tournaments').update({ status: 'active', started_at: nowIso, current_round: 1, round_started_at: nowIso }).eq('id', LOBBY.state.tournamentId);
                if (updateError) throw updateError;
                showToast('Tournament started!', 'success');
                beginTournamentRounds(); 
            } catch (err) {
                console.error(err);
                showToast('Error starting tournament', 'error');
            }
        }

        async function joinExistingLobby() {
            const nameInput = document.getElementById('tournamentArtistName');
            const playerName = nameInput ? nameInput.value.trim() : '';
            if (!playerName || playerName === '' || playerName === 'Anonymous') {
                showToast('Please fill in your artist name first!', 'error');
                return;
            }
            LOBBY.state.playerName = playerName;
            document.getElementById('artistName').value = playerName;    
            try {
                const input = document.getElementById('joinLobbyCodeInput');
                if (!input) return;
                const code = input.value.trim().toUpperCase();
                if (!code) { showToast('Enter a lobby code', 'error'); return; }
                const { data: tournament, error } = await client.from('tournaments').select('*').eq('lobby_code', code).eq('status', 'waiting').single();
                if (error || !tournament) { showToast('Dawg cant be found, woof', 'error'); return; }
                const player = await LOBBY.addPlayerToLobby(tournament, playerName);
                if (!player) return;
                LOBBY.state.tournamentId = tournament.id;
                const players = await LOBBY.getPlayersInLobby(tournament.id);
                LOBBY.showLobbyUI(tournament, players);
                LOBBY.startLobbyPolling();
            } catch (err) {
                console.error(err);
                showToast('Error joining lobby', 'error');
            }
        }

        function beginTournamentRounds() {
            TOURNAMENT.currentRound = 1;
            const pCount = TOURNAMENT.players.length || 2; 
            TOURNAMENT.totalRounds = pCount > 2 ? 2 : 1;
            showTournamentDrawingRound();
        }

        function showTournamentDrawingRound() {
            const container = document.getElementById('tournamentDrawing');
            const welcome = document.getElementById('tournamentWelcome');
            const lobby = document.getElementById('tournamentLobby');
            const results = document.getElementById('tournamentResults');

            if (!container) return;
            if (welcome) welcome.style.display = 'none';
            if (lobby) lobby.style.display = 'none';
            if (results) results.style.display = 'none';

            container.style.display = 'block';
            TOURNAMENT.referenceDogIndex = Math.floor(Math.random() * CONFIG.dogs.length);
            const refDog = CONFIG.dogs[TOURNAMENT.referenceDogIndex];
            const refSelect = document.getElementById('refSelect');
            if (refSelect) {
                refSelect.value = TOURNAMENT.referenceDogIndex;
                const event = new Event('change');
                refSelect.dispatchEvent(event);
            }
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            saveHistory();

            container.innerHTML = `
                <div class="neu-box" style="text-align:center;">
                    <h2>${buildTournamentRoundTitle()}</h2>
                    <p>Reference: <strong>${refDog.name}</strong> ‚Äì You have 3 minutes to draw.</p>
                    <p>Time left: <span id="tournamentRoundCountdown">180</span> seconds</p>
                    <p>Use the drawing canvas in the "Draw" tab.</p>
                </div>
            `;
            activateTab('draw');
            loadTournamentState().then(state => {
                if (!state || !state.round_started_at) {
                    startTournamentCountdownFromTimestamp(new Date().toISOString(), TOURNAMENT_DRAW_TIME_SECONDS);
                    return;
                }
                const duration = state.draw_time_seconds || TOURNAMENT_DRAW_TIME_SECONDS;
                startTournamentCountdownFromTimestamp(state.round_started_at, duration);
            });
        }

        async function loadTournamentState() {
            try {
                const { data } = await client.from('tournaments').select('*').eq('id', LOBBY.state.tournamentId).single();
                return data;
            } catch (e) { return null; }
        }

        function startTournamentCountdownFromTimestamp(startTimeIso, durationSeconds) {
            const countdownEl = document.getElementById('tournamentRoundCountdown');
            const statusHeader = document.getElementById('tournamentStatusHeader');
            const roundNameEl = document.getElementById('tournamentRoundName');
            const timeDisplayEl = document.getElementById('tournamentTimeDisplay');
            
            const startTime = new Date(startTimeIso).getTime();
            const endTime = startTime + (durationSeconds * 1000);
            if (TOURNAMENT.roundTimerId) clearInterval(TOURNAMENT.roundTimerId);
            if (statusHeader) statusHeader.style.display = 'block';
            if (roundNameEl) roundNameEl.textContent = TOURNAMENT.currentRound === 1 && TOURNAMENT.players.length > 2 ? 'Qualification' : 'Final';

            TOURNAMENT.roundTimerId = setInterval(() => {
                const now = Date.now();
                const leftMs = endTime - now;
                let leftSec = Math.ceil(leftMs / 1000);
                if (leftSec < 0) leftSec = 0;
                if (countdownEl) countdownEl.textContent = leftSec;
                if (timeDisplayEl) {
                    const mins = Math.floor(leftSec / 60);
                    const secs = leftSec % 60;
                    timeDisplayEl.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
                }
                TOURNAMENT.roundTimeLeft = leftSec;
                if (leftSec <= 0) {
                    clearInterval(TOURNAMENT.roundTimerId);
                    if (statusHeader) statusHeader.style.display = 'none';
                    showToast('the dawg is done! Score is being calculated...', 'info');
                    onTournamentRoundEnd();
                }
            }, 1000);
        }

        function buildTournamentRoundTitle() {
            const players = TOURNAMENT.players.length;
            if (players === 2) return 'Final Round';
            if (players > 2 && TOURNAMENT.currentRound === 1) return 'Knock-out Round';
            return 'Final Round';
        }

        async function onTournamentRoundEnd() {
            const overlay = document.createElement('div');
            overlay.id = "roundEndOverlay";
            overlay.style = "position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:9999; display:flex; flex-direction:column; align-items:center; justify-content:center; color:white; font-family:sans-serif;";
            overlay.innerHTML = `<h1 style="font-size:4rem; margin-bottom:20px; animation: bounce 0.5s infinite;">‚åõ TIMES UP!</h1><p style="font-size:1.5rem;">A dawg is examining your work...</p>`;
            document.body.appendChild(overlay);
            setTimeout(() => {
                const el = document.getElementById('roundEndOverlay');
                if(el) el.remove();
                activateTab('tournament');
            }, 3000);

            try {
                const scores = calculateAccuracy(); 
                const totalScore = scores.total || 0;
                if (LOBBY.state.playerId && LOBBY.state.tournamentId) {
                    await client.from('tournament_rounds').insert([{
                        tournament_id: LOBBY.state.tournamentId,
                        player_id: LOBBY.state.playerId,
                        round_index: TOURNAMENT.currentRound,
                        total_score: totalScore,
                        color_score: scores.color || 0,
                        shape_score: scores.shape || 0,
                        reference_dog_index: TOURNAMENT.referenceDogIndex
                    }]);
                }
                await showTournamentResultsForCurrentRound();
            } catch (err) {
                console.error(err);
                showToast('Error saving tournament round score', 'error');
            }
        }

        async function showTournamentResultsForCurrentRound() {
            const container = document.getElementById('tournamentResults');
            const drawingView = document.getElementById('tournamentDrawing');
            if (!container) return;
            if (drawingView) drawingView.style.display = 'none';
            container.style.display = 'block';
            showToast('retrieving results...', 'info');
            await new Promise(r => setTimeout(r, 4000));
            const { data: roundScores, error } = await client.from('tournament_rounds').select('*, tournament_players(player_name)').eq('tournament_id', LOBBY.state.tournamentId).eq('round_index', TOURNAMENT.currentRound);
            if (error) { showToast('Error loading results', 'error'); return; }
            const entries = (roundScores || []).sort((a, b) => b.total_score - a.total_score);

            // Rebuilt HTML for Neubrutalism style
            let html = `
                <div class="neu-box">
                    <h2 style="text-align:center;">Standings: ${TOURNAMENT.currentRound === 1 ? 'Qualification' : 'Final'}</h2>
                    <div style="overflow-x: auto;">
                        <table style="width:100%; border-collapse: collapse; margin-top:15px;">
                            <thead>
                                <tr style="border-bottom: 3px solid black; text-align:left;">
                                    <th>#</th><th>Player</th><th>Shape</th><th>Color</th><th>TOTAL</th><th>Status</th>
                                </tr>
                            </thead>
                            <tbody>`;

            entries.forEach((entry, index) => {
                const isMe = entry.player_id === LOBBY.state.playerId;
                const playerName = entry.tournament_players?.player_name || 'Unknown';
                let statusBadge = "";
                if (TOURNAMENT.currentRound === 1 && TOURNAMENT.players.length > 2) {
                    statusBadge = index < 2 ? '‚úÖ FINALIST' : '‚ùå OUT';
                } else {
                    statusBadge = index === 0 ? 'üèÜ WINNER' : 'ü•à 2nd';
                }
                html += `
                    <tr style="border-bottom: 2px dashed #ccc; ${isMe ? 'background:var(--accent-yellow);' : ''}">
                        <td style="padding:10px;">${index + 1}</td>
                        <td style="padding:10px; font-weight:bold;">${escapeHtml(playerName)}</td>
                        <td style="padding:10px;">${entry.shape_score}%</td>
                        <td style="padding:10px;">${entry.color_score}%</td>
                        <td style="padding:10px; font-size:1.2rem; font-weight:bold;">${entry.total_score.toFixed(0)}</td>
                        <td style="padding:10px; font-size:0.8rem;">${statusBadge}</td>
                    </tr>`;
            });
            html += `</tbody></table></div></div>`;
            container.innerHTML = html;
            
            const totalRoundsNeeded = TOURNAMENT.players.length > 2 ? 2 : 1;
            if (TOURNAMENT.currentRound < totalRoundsNeeded) {
                const finalists = entries.slice(0, 2).map(e => e.player_id);
                const amIFinalist = finalists.includes(LOBBY.state.playerId);
                if (amIFinalist) {
                    showToast('Congrats! You reached the final!', 'success');
                    setTimeout(async () => {
                        TOURNAMENT.currentRound++;
                        await client.from('tournaments').update({ current_round: TOURNAMENT.currentRound, round_started_at: new Date().toISOString() }).eq('id', LOBBY.state.tournamentId);
                        showTournamentDrawingRound();
                    }, 8000);
                } else {
                    setTimeout(() => { container.innerHTML = `<div class="neu-box" style="text-align:center;"><h2>Unlucky...</h2><p>You didn't make the cut.</p><button class="neu-btn" onclick="location.reload()">Leave</button></div>`; }, 8000);
                }
            } else {
                showToast('Tournament over, calculating winner...', 'success');
                setTimeout(() => { determineTournamentWinner(); }, 5000);
            }    
        } 

        async function determineTournamentWinner() {
            try {
                const container = document.getElementById('tournamentResults');
                if (!container) return;
                const { data: allRounds, error } = await client.from('tournament_rounds').select('*, tournament_players(player_name)').eq('tournament_id', LOBBY.state.tournamentId);
                if (error || !allRounds) return;
                const totals = {};
                allRounds.forEach(r => {
                    const pid = r.player_id;
                    if (!totals[pid]) { totals[pid] = { name: r.tournament_players?.player_name || 'Unknown', score: 0, id: pid }; }
                    totals[pid].score += (Number(r.total_score) || 0);
                });
                const scoreboard = Object.values(totals).sort((a, b) => b.score - a.score);
                const winner = scoreboard[0];
                let finalName = document.getElementById('artistName').value.trim();
                
                if (LOBBY.state.playerId === winner.id) {
                    if (!finalName || finalName === 'Anonymous') {
                        const promptedName = prompt("üèÜ You won! Name for Hall of Fame:", "");
                        finalName = promptedName ? promptedName.trim() : "Tournament Dawg";
                        document.getElementById('artistName').value = finalName;
                    }
                    await client.from('tournament_winners').insert([{ tournament_id: LOBBY.state.tournamentId, winner_name: finalName, final_score: winner.score, player_count: scoreboard.length }]);
                    const winScores = calculateAccuracy(); 
                    winScores.isTournamentWinner = true;
                    const { error: pubError } = await client.from('drawings').insert([{ title: "üèÜ Tournament Winner", artist_name: finalName, image_data: canvas.toDataURL(), scores: winScores, votes: 0 }]);
                    if (!pubError) { showToast('Winning art pinned! üëë', 'success'); loadDrawingsFromSupabase(); }
                } else { finalName = winner.name; }

                document.getElementById('btnSubmit').style.display = 'block';
                container.innerHTML = `
                    <div class="neu-box" style="text-align:center;">
                        <div style="font-size: 4rem;">üèÜ</div>
                        <h2>TOURNAMENT WINNER</h2>
                        <h1>${escapeHtml(finalName)}</h1>
                        <p>Score: <strong>${winner.score.toFixed(0)}</strong></p>
                        <button class="neu-btn" onclick="location.reload()">Leave Tournament</button>
                    </div>`;
            } catch (err) { console.error("Error determining winner:", err); }
        }

        async function loadTournamentHallOfFame() {
            const container = document.getElementById('tournamentHallOfFame');
            const listEl = document.getElementById('tournamentHallOfFameList');
            if (!container || !listEl) return;
            const { data, error } = await client.from('tournament_winners').select('*').order('completed_at', { ascending: false }).limit(20);
            if (error || !data || data.length === 0) { container.style.display = 'none'; return; }
            container.style.display = 'block';
            listEl.innerHTML = data.map((w, index) => `
                <div class="rank-row">
                    <div class="rank-num">${index + 1}</div>
                    <div>
                        <div style="font-weight:700;">${w.winner_name || 'Anonymous'}</div>
                        <div style="font-size:0.85rem;">Score: ${w.final_score || '?'}</div>
                    </div>
                </div>`).join('');
        }

        function openModal(imgSrc, artistName) {
            const modal = document.getElementById('artModal');
            const modalImg = document.getElementById('modalImg');
            const captionText = document.getElementById('modalCaption');
            modal.style.display = "block";
            modalImg.src = imgSrc;
            captionText.innerHTML = "By: " + artistName;
            document.body.style.overflow = 'hidden';
        }
        function closeModal() {
            document.getElementById('artModal').style.display = "none";
            document.body.style.overflow = 'auto';
        }
        function downloadCanvasImage() {
            const img = document.getElementById('modalImg');
            if (!img || !img.src) { showToast('No image found', 'error'); return; }
            const link = document.createElement('a');
            link.download = 'dog-masterpiece.png';
            link.href = img.src;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        function saveData() {
            // We slaan alleen je eigen stemmen op, dat neemt bijna geen ruimte in.
            // De tekeningen zelf halen we wel uit de database.
            localStorage.setItem('hddc_votes', JSON.stringify([...STATE.myVotes]));
            
            updateGlobalStats();
        }
        function updateGlobalStats() {
            document.getElementById('statTotalDrawings').textContent = STATE.drawings.length;
            const totalVotes = STATE.drawings.reduce((sum, d) => sum + d.votes, 0);
            document.getElementById('statTotalVotes').textContent = totalVotes;
        }
        function showToast(msg, type) {
            const t = document.getElementById('toast');
            t.textContent = msg;
            t.className = `toast show ${type}`;
            setTimeout(() => t.className = 'toast', 3000);
        }
        function escapeHtml(text) {
            if (!text) return text;
            return text
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }


        // --- COPY CONTRACT (IMPROVED) ---
        function copyContractAddress() {
            const ca = "6ZKCEQPT7hULSD4iU9j4UXUA5gDbtuNLM93sXQx6BAGS";
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(ca).then(() => {
                    showToast("Contract Address Copied! üìã", "success");
                }).catch(err => fallbackCopy(ca));
            } else {
                fallbackCopy(ca);
            }
        }
        function fallbackCopy(text) {
            const textArea = document.createElement("textarea");
            textArea.value = text;
            document.body.appendChild(textArea);
            textArea.select();
            try {
                document.execCommand('copy');
                showToast("Contract Address Copied! üìã", "success");
            } catch (err) { alert("CA: " + text); }
            document.body.removeChild(textArea);
        }

       // --- EVENT BINDINGS ---
       
       // HIER IS DE FIX: We koppelen de Undo functie weer aan de knop
       document.getElementById('btnUndo').onclick = undo;

      // Hier begint de Prullenbak code
       // Hier begint de Prullenbak code
      document.getElementById('btnClear').onclick = () => { 
    // 1. Reset de beveiliging en AI status
    STATE.isReplaying = false;
    STATE.isAI = false; 

    // UI Resetten (Verberg replay knoppen)
    document.getElementById('replayControls').style.display = 'none';

    // 2. KNOPPEN RESETTEN (Dit is nieuw)
    // Zet de normale Publish knop terug
    document.getElementById('btnSubmit').style.display = 'block'; 
    // Verberg de AI knoppen
    document.getElementById('btnDownloadOnly').style.display = 'none'; 
    document.getElementById('btnResetAI').style.display = 'none'; 

    // Maak het naamveld weer actief
    const artistInput = document.getElementById('artistName');
    artistInput.disabled = false; 
    if(artistInput.value === "AI Generated Art") artistInput.value = "";

    // Reset de Publish knop tekst
    const submitBtn = document.getElementById('btnSubmit');
    if(submitBtn) {
        submitBtn.disabled = false; 
        submitBtn.textContent = 'PUBLISH'; 
        submitBtn.style.opacity = '1';
    }

    // Je mag weer tekenen
    canvas.style.pointerEvents = 'auto'; 

    // 3. Wis het canvas echt
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // 4. Sla dit lege canvas op in de geschiedenis
    saveHistory(); 
    STATE.recording = [];
};
        const tools = { btnPen: 'pen', btnBrush: 'brush', btnCalligraphy: 'calligraphy', btnEraser: 'eraser', btnFill: 'fill' };
        Object.keys(tools).forEach(id => {
            const el = document.getElementById(id);
            if(el) {
                el.onclick = (e) => {
                    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                    el.classList.add('active');
                    STATE.tool = tools[id];
                };
            }
        });

        document.getElementById('colorPicker').onchange = (e) => STATE.color = e.target.value;
        document.getElementById('sizeSlider').oninput = (e) => STATE.baseLineWidth = e.target.value;
        document.getElementById('toggleRef').onchange = updateOverlay;
        document.getElementById('opacitySlider').oninput = updateOverlay;

// --- BACKGROUND CHANGER ---
        const bgSelect = document.getElementById('bgSelect');
        if (bgSelect) {
            bgSelect.addEventListener('change', (e) => {
                const type = e.target.value;
                const canvasWrapper = document.querySelector('.canvas-wrapper');
                
                // Reset eerst alles naar wit
                canvasWrapper.style.backgroundImage = '';
                STATE.currentBgImage = null; 

                if (type && CONFIG.backgrounds[type]) {
                    const url = CONFIG.backgrounds[type];
                    // Zet de achtergrond op de container (achter het canvas)
                    canvasWrapper.style.backgroundImage = `url('${url}')`;
                    
                    // Preload de image in het geheugen voor tijdens het uploaden
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.src = url;
                    STATE.currentBgImage = img;
                }
            });
        }

        // --- LOAD DATA ---
        window.addEventListener('load', async function() {
            init();
            await loadDrawingsFromSupabase();
            document.getElementById('btnSubmit').addEventListener('click', publishDrawingToSupabase);
        });

        async function publishDrawingToSupabase() {
            const titleInput = document.getElementById('dogTitle');
            const artistInput = document.getElementById('artistName');

            const title = titleInput.value.trim();
            const artist = artistInput.value.trim();
            // --- SAMENVOEGEN VAN ACHTERGROND EN TEKENING ---
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tCtx = tempCanvas.getContext('2d');

            // 1. Teken de achtergrond (of wit als er geen is)
            if (STATE.currentBgImage) {
                const img = STATE.currentBgImage;
                // Slimme berekening om het plaatje 'cover' te laten fitten
                const scale = Math.max(tempCanvas.width / img.width, tempCanvas.height / img.height);
                const x = (tempCanvas.width / 2) - (img.width / 2) * scale;
                const y = (tempCanvas.height / 2) - (img.height / 2) * scale;
                tCtx.drawImage(img, x, y, img.width * scale, img.height * scale);
            } else {
                tCtx.fillStyle = '#FFFFFF';
                tCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            }

            // 2. Teken jouw kunstwerk er overheen
            tCtx.drawImage(canvas, 0, 0);

            // 3. Maak hier de uiteindelijke foto van
            const imageData = tempCanvas.toDataURL();
            // -----------------------------------------------
            const scores = calculateAccuracy();

            if (!title || !artist) {
                alert('Please fill in title and artist name!');
                return;
            }

            try {
                // DATA VOORBEREIDEN
                const payload = { 
                    title: title, 
                    artist_name: artist, 
                    image_data: imageData,
                    scores: scores,
                    votes: 0,
                    replay_data: STATE.recording,
                    // NIEUWE VELDEN:
                    is_daily: STATE.isDailyChallenge,
                    daily_date: STATE.isDailyChallenge ? STATE.currentDailyDate : null
                };

                const { data, error } = await client.from('drawings').insert([payload]);

                if (error) throw error;

                // ALS HET EEN DAILY WAS:
                if (STATE.isDailyChallenge) {
                    localStorage.setItem(`hdd_daily_${STATE.currentDailyDate}`, 'true');
                    showToast('Daily Challenge Completed! Gallery Unlocked üîì', 'success');
                    // Ga automatisch naar de daily tab
                    setTimeout(() => activateTab('daily'), 1500);
                } else {
                    showToast('Drawing published to Supabase! üéâ', 'success');
                    await loadDrawingsFromSupabase();
                    renderGallery();
                }

                // RESET
                titleInput.value = '';
                artistInput.value = '';
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                STATE.history = [];
                STATE.historyStep = -1;
                STATE.recording = [];
                STATE.recordingHistory = [];
            } catch (err) {
                console.error('Error publishing:', err);
                showToast('Error saving to Supabase!', 'error');
            }
        }

        async function loadDrawingsFromSupabase() {
    try {
        const { data, error } = await client
        .from('drawings')
        .select('*')
        .eq('is_daily', false) // NIEUW: Verberg daily challenges in de normale galerij
        .order('votes', { ascending: false });

        if (error) throw error;

        STATE.drawings = data.map(d => ({
            id: d.id,
            artist: d.artist_name,
            image: d.image_data,
            votes: d.votes,
            scores: d.scores || { total: 0, color: 0, shape: 0 },
replay_data: d.replay_data || [],
            timestamp: new Date(d.created_at).getTime(),
            isLocal: false
        }));

        // DEZE REGELS ZORGEN DAT DE CIJFERS DIRECT VERSCHIJNEN:
        updateGlobalStats();
        renderGallery();

    } catch (err) {
        console.error('Error loading drawings:', err);
    }
}

// --- DAILY CHALLENGE LOGIC ---
     // We houden bij hoeveel dagen we terug kijken (0 = vandaag, -1 = gisteren)
        let dailyOffset = 0;

        function getDailyDateString(offset = 0) {
            const now = new Date();
            now.setDate(now.getDate() + offset); // Tel de dagen erbij op/af
            
            const year = now.getUTCFullYear();
            const month = String(now.getUTCMonth() + 1).padStart(2, '0');
            const day = String(now.getUTCDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function changeDailyDay(delta) {
            const newOffset = dailyOffset + delta;

            // 1. Toekomst Check (Morgen mag niet)
            if (newOffset > 0) {
                showToast("You cannot look into the future! üîÆ", "error");
                return;
            }

            // 2. Verleden Check (Voor startdatum mag niet)
            // ‚ñº PAS DEZE DATUM AAN NAAR DE START VAN JE CHALLENGE (YYYY-MM-DD) ‚ñº
            const START_DATE = "2026-02-08"; 
            
            const targetDate = getDailyDateString(newOffset);
            if (targetDate < START_DATE) {
                showToast("The challenge hadn't started yet! üë∂", "error");
                return;
            }

            // Als alles goed is, update de dag
            dailyOffset = newOffset;
            checkDailyStatus(); 
        }

        function getDailyPrompt(dateStr) {
            // Genereer de prompt op basis van de datum-string
            let hash = 0;
            for (let i = 0; i < dateStr.length; i++) hash = dateStr.charCodeAt(i) + ((hash << 5) - hash);
            const index = Math.abs(hash) % (CONFIG.prompts || []).length;
            return CONFIG.prompts ? CONFIG.prompts[index] : "Draw a happy dog";
        }

        function checkDailyStatus() {
            // 1. Welke datum bekijken we?
            const viewDate = getDailyDateString(dailyOffset);
            const todayDate = getDailyDateString(0);
            
            STATE.currentDailyDate = todayDate; // Als we tekenen, is het altijd voor "Vandaag"

            // 2. Update de datum tekst (bijv. "Day 1 (2023-10-27)")
            const dateDisplay = document.getElementById('dailyDateDisplay');
            if(dateDisplay) {
                if(dailyOffset === 0) dateDisplay.textContent = `Today (${viewDate})`;
                else if(dailyOffset === -1) dateDisplay.textContent = `Yesterday (${viewDate})`;
                else dateDisplay.textContent = viewDate;
            }

            // 3. Toon de juiste prompt
            const prompt = getDailyPrompt(viewDate);
            document.getElementById('dailyPromptDisplay').textContent = `"${prompt}"`;
            
            // Update ook de tekst boven het canvas (alleen als we op "vandaag" staan relevant)
            if(dailyOffset === 0) {
                 const txtEl = document.getElementById('drawingPromptText');
                 if(txtEl) txtEl.textContent = prompt;
            }

            // 4. UI Status bepalen
            const actionArea = document.getElementById('dailyActionArea');
            const lockedView = document.getElementById('dailyGalleryLocked');
            const galleryView = document.getElementById('dailyGallery');

            // SITUATIE A: We kijken in het verleden (Archief)
            if (dailyOffset < 0) {
                actionArea.innerHTML = `<div style="padding:10px; background:#eee; border-radius:8px;">üìú Viewing Archive</div>`;
                lockedView.style.display = 'none';
                galleryView.style.display = 'grid';
                loadDailyGallery(viewDate); // Laad de groep van die dag
                return;
            }

            // SITUATIE B: We kijken naar vandaag
            const hasCompleted = localStorage.getItem(`hdd_daily_${todayDate}`);
            if (hasCompleted) {
                actionArea.innerHTML = `<button class="neu-btn" disabled style="opacity:0.6; cursor:not-allowed;">‚úÖ Challenge Completed! Come back tomorrow.</button>`;
                lockedView.style.display = 'none';
                galleryView.style.display = 'grid';
                loadDailyGallery(viewDate);
            } else {
                actionArea.innerHTML = `<button class="neu-btn btn-green" onclick="startDailyChallenge()">üöÄ Start Challenge</button>`;
                lockedView.style.display = 'block';
                galleryView.style.display = 'none';
            }
        }

        function startDailyChallenge() {
            STATE.isDailyChallenge = true;
            activateTab('draw');
            
            document.getElementById('drawTitle').textContent = "üìÖ Daily Challenge";
            document.getElementById('drawingPromptBanner').style.display = 'block';
            
            // Blokkeer opties
            const bgSelect = document.getElementById('bgSelect');
            bgSelect.value = ""; 
            bgSelect.disabled = true;
            
            // Trigger change om wit te maken
            bgSelect.dispatchEvent(new Event('change'));

            const titleInput = document.getElementById('dogTitle');
            titleInput.value = "Daily: " + getDailyDateString();
            titleInput.disabled = true;

            showToast("Challenge Started! No custom backgrounds allowed.", "info");
        }

       async function loadDailyGallery(dateStr) {
            const grid = document.getElementById('dailyGallery');
            grid.innerHTML = '<p>Loading daily masterpieces...</p>';

            const { data, error } = await client
                .from('drawings')
                .select('*')
                .eq('is_daily', true)
                .eq('daily_date', dateStr)
                .order('votes', { ascending: false });

            if (error || !data || data.length === 0) {
                grid.innerHTML = '<p>No drawings yet today. Be the first!</p>';
                return;
            }

            // STAP 1: Sla ze op in de STATE zodat we kunnen stemmen
            STATE.dailyDrawings = data.map(d => ({
                id: d.id,
                artist: d.artist_name,
                image: d.image_data, // Let op: consistentie in naamgeving
                votes: d.votes,
                scores: d.scores || { total: 0 },
                is_daily: true
            }));

            // STAP 2: Render de HTML vanuit de STATE (niet direct vanuit data)
            grid.innerHTML = STATE.dailyDrawings.map(d => {
                const safeArtist = escapeHtml(d.artist).replace(/'/g, "\\'");
                const safeImage = d.image; 
                
                // Check of we al gestemd hebben
                const isVoted = STATE.myVotes.has(d.id);
                const btnClass = isVoted ? 'neu-btn' : 'neu-btn btn-green';
                const btnText = isVoted ? '‚úÖ Voted' : '‚ù§Ô∏è Vote';

                return `
                <div class="art-card" onclick="openModal('${safeImage}', '${safeArtist}')">
                    <img src="${safeImage}" class="art-image">
                    <div class="art-info">
                        <div style="font-weight:700;">${escapeHtml(d.artist)}</div>
                        <div style="font-size:0.8rem;">‚ù§Ô∏è ${d.votes} | Score: ${d.scores?.total || 0}%</div>
                        <button class="${btnClass}" style="width:100%; margin-top:5px; padding:5px;" onclick="event.stopPropagation(); vote(${d.id})">${btnText}</button>
                    </div>
                </div>`;
            }).join('');
        }

  // --- SMART CHAIN STATS (LIVE BURN + MANUAL LOCKED) ---
        async function fetchChainStats() {
            const CA = "6ZKCEQPT7hULSD4iU9j4UXUA5gDbtuNLM93sXQx6BAGS";
            const INITIAL_SUPPLY = 1_000_000_000; 

            // HIER STAAT JE VASTE TOTAAL (De optelsom van Jupiter)
            // 50M + 15M + 10M + 10M + 9M + 8.2M + 8M + 3M = 113.262.402
            const MANUAL_LOCKED_AMOUNT = 113262402;

            const widget = document.getElementById('statsWidget');
            if(widget) widget.style.display = 'block';

            // Publieke nodes (als er een faalt, pakt hij de volgende)
            const RPC_ENDPOINTS = [
                "https://solana-rpc.publicnode.com",
                "https://rpc.ankr.com/solana",
                "https://api.mainnet-beta.solana.com"
            ];

            for (const rpcUrl of RPC_ENDPOINTS) {
                try {
                    const connection = new solanaWeb3.Connection(rpcUrl, 'confirmed');
                    const pubKey = new solanaWeb3.PublicKey(CA);

                    // 1. BURN DATA (Dit doen we wel live)
                    const tokenSupply = await connection.getTokenSupply(pubKey);
                    const currentSupply = tokenSupply.value.uiAmount; 
                    const burnedAmount = INITIAL_SUPPLY - currentSupply;
                    
                    // Bereken Burn %
                    const burnedPercent = (burnedAmount / INITIAL_SUPPLY) * 100;

                    // Update Burn UI
                    document.getElementById('burnPercentDisplay').textContent = `${burnedPercent.toFixed(1)}%`;
                    document.getElementById('burnProgressBar').style.width = `${burnedPercent}%`;
                    document.getElementById('burnTotalDisplay').textContent = `${Math.floor(burnedAmount).toLocaleString()} $HDD`;

                    // 2. LOCKED DATA (Handmatig)
                    // Bereken Locked % ten opzichte van de HUIDIGE (circulating) supply
                    const lockedPercent = (MANUAL_LOCKED_AMOUNT / currentSupply) * 100;

                    // Update Locked UI
                    document.getElementById('liqPercentDisplay').textContent = `${lockedPercent.toFixed(1)}%`;
                    document.getElementById('liqProgressBar').style.width = `${lockedPercent}%`;
                    document.getElementById('liqTotalDisplay').textContent = `${Math.floor(MANUAL_LOCKED_AMOUNT).toLocaleString()} $HDD`;

                    // Klaar! Stop de loop.
                    break; 

                } catch (err) {
                    console.warn(`Node ${rpcUrl} failed, trying next...`);
                }
            }
        }
        
        // Start direct bij laden
        fetchChainStats();
// --- AI DAWGS GENERATOR ---
      async function generateAIDawg() {
            const input = document.getElementById('aiPromptInput');
            const loading = document.getElementById('aiLoading');
            let userText = input.value.trim();

            if (!userText) {
                showToast("Woof! You need to type something first!", "error");
                return;
            }

            // UI Aanzetten
            input.disabled = true;
            loading.style.display = 'block';

            // --- DE MARKETING MASTER FORMULE ---
            // 1. "Sticker style" & "High contrast" zorgt dat het van het scherm spat (goed voor socials)
            // 2. "Thick chaotic lines" zorgt voor die herkenbare $HDD vibe
            // 3. "Waxy oil pastel" zorgt voor de kleurdiepte
            const styleInstructions = "naive children's crayon drawing, waxy oil pastel texture, rough scribbles, bold thick lines, bright primary colors, white paper background, high contrast, sticker art style, whimsical, expressive, masterpiece of a 5 year old";

            // --- DE SAMENVOEGING ---
            // Jouw tekst EERST (voor precisie), daarna de marketing-saus
            const finalPrompt = encodeURIComponent(`${userText}, ${styleInstructions}`);
            
            // -------------------------

            const seed = Math.floor(Math.random() * 1000000);

            // De URL (Pollinations.ai)
            // We gebruiken flux model voor de beste prompt-volging
            const imageUrl = `https://image.pollinations.ai/prompt/${finalPrompt}?width=600&height=450&seed=${seed}&nologo=true&model=flux`;

            const img = new Image();
            img.crossOrigin = "Anonymous";
            img.src = imageUrl;

            img.onload = () => {
                // HET POEF MOMENT
                activateTab('draw'); 

                // Canvas resetten en wit maken
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = "#FFFFFF";
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Tekenen
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                // --- AI MODUS AAN (Beveiliging) ---
                STATE.isAI = true; 
                
                // Knoppen wisselen
                document.getElementById('btnSubmit').style.display = 'none'; 
                document.getElementById('btnDownloadOnly').style.display = 'block'; 
                document.getElementById('btnResetAI').style.display = 'block'; 
                
                // Blokkeer naam
                document.getElementById('artistName').disabled = true; 
                document.getElementById('artistName').value = "AI Generated Art";

                // Reset UI
                loading.style.display = 'none';
                input.disabled = false;
                input.value = ""; 

                STATE.isDrawing = false;
                saveHistory(); 
                
                showToast("Poof! Marketing Art generated üñçÔ∏è", "success");
            };

            img.onerror = () => {
                loading.style.display = 'none';
                input.disabled = false;
                showToast("The AI Dawg is sleeping (Error). Try again!", "error");
            };
        }



// --- NIEUWE DOWNLOAD FUNCTIE ---
function downloadCurrentCanvas() {
    // 1. Maak een tijdelijk canvas
    const tempCanvas = document.createElement('canvas');
    tempCanvas.width = canvas.width;
    tempCanvas.height = canvas.height;
    const tCtx = tempCanvas.getContext('2d');

    // 2. Vul de achtergrond (wit of plaatje)
    if (STATE.currentBgImage) {
        const img = STATE.currentBgImage;
        const scale = Math.max(tempCanvas.width / img.width, tempCanvas.height / img.height);
        const x = (tempCanvas.width / 2) - (img.width / 2) * scale;
        const y = (tempCanvas.height / 2) - (img.height / 2) * scale;
        tCtx.drawImage(img, x, y, img.width * scale, img.height * scale);
    } else {
        tCtx.fillStyle = '#FFFFFF';
        tCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
    }

    // 3. Teken jouw kunstwerk eroverheen
    tCtx.drawImage(canvas, 0, 0);

    // 4. Start de download
    const link = document.createElement('a');
    link.download = 'ai-dawg-masterpiece.png';
    link.href = tempCanvas.toDataURL();
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);

    showToast("Saved to your photos! üì∏", "success");
}

    </script>
</body>
</html>
