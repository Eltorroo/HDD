<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hand Drawn Dog Competition - Pro Edition</title>
    <style>
        :root {
            /* Brand Colors: Warm, Earthy yet Premium */
            --c-cream: #FDFBF7;
            --c-surface: #FFFFFF;
            --c-surface-alt: #F3F4F6;
            
            --c-primary: #D97706; /* Warm Amber */
            --c-primary-hover: #B45309;
            --c-secondary: #78350F; /* Deep Brown */
            
            --c-text-main: #1F2937;
            --c-text-muted: #6B7280;
            
            --c-accent-teal: #14B8A6;
            --c-accent-rose: #F43F5E;

            --radius-md: 12px;
            --radius-lg: 16px;
            --radius-pill: 9999px;
            
            --shadow-sm: 0 1px 2px rgba(0,0,0,0.05);
            --shadow-md: 0 4px 6px -1px rgba(0,0,0,0.1);
            --shadow-lg: 0 10px 15px -3px rgba(0,0,0,0.1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --c-cream: #111827;
                --c-surface: #1F2937;
                --c-surface-alt: #374151;
                --c-text-main: #F9FAFB;
                --c-text-muted: #9CA3AF;
            }
        }

        * { margin: 0; padding: 0; box-sizing: border-box; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; touch-action: none; /* Prevents scrolling while drawing */ }

        body {
            background-color: var(--c-cream);
            color: var(--c-text-main);
            line-height: 1.5;
            padding-bottom: 40px;
            overscroll-behavior: none;
        }

        /* --- HERO SECTION --- */
        .hero {
            background: linear-gradient(135deg, var(--c-surface) 0%, var(--c-surface-alt) 100%);
            padding: 60px 20px 40px;
            text-align: center;
            border-bottom: 1px solid rgba(0,0,0,0.05);
        }

        .hero h1 {
            font-size: 3rem;
            font-weight: 800;
            color: var(--c-secondary);
            margin-bottom: 16px;
            letter-spacing: -0.02em;
        }

        .hero p {
            font-size: 1.25rem;
            color: var(--c-text-muted);
            max-width: 600px;
            margin: 0 auto 32px;
        }

        .hero-stats {
            display: flex;
            justify-content: center;
            gap: 24px;
            margin-bottom: 32px;
            font-size: 0.9rem;
            color: var(--c-text-muted);
        }

        .hero-stats strong { color: var(--c-primary); }

        .btn-cta {
            background: var(--c-primary);
            color: white;
            font-size: 1.1rem;
            font-weight: 600;
            padding: 16px 48px;
            border-radius: var(--radius-pill);
            border: none;
            cursor: pointer;
            box-shadow: var(--shadow-md);
            transition: transform 0.2s, box-shadow 0.2s;
            touch-action: manipulation;
        }

        .btn-cta:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
            background: var(--c-primary-hover);
        }

        /* --- STICKY NAV --- */
        .nav-container {
            position: sticky;
            top: 0;
            z-index: 100;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(0,0,0,0.05);
            padding: 10px 20px;
            margin-bottom: 40px;
        }
        
        @media (prefers-color-scheme: dark) {
            .nav-container { background: rgba(31, 41, 55, 0.9); }
        }

        .nav-tabs {
            display: flex;
            justify-content: center;
            gap: 8px;
            max-width: 800px;
            margin: 0 auto;
        }

        .nav-tab {
            padding: 10px 20px;
            border-radius: var(--radius-pill);
            border: none;
            background: transparent;
            color: var(--c-text-muted);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .nav-tab:hover { background: var(--c-surface-alt); color: var(--c-text-main); }
        .nav-tab.active { background: var(--c-text-main); color: var(--c-surface); }

        /* --- LAYOUT --- */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        .tab-content { display: none; animation: fadeIn 0.4s ease; }
        .tab-content.active { display: block; }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* --- DRAWING INTERFACE --- */
        .drawing-card {
            background: var(--c-surface);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-md);
            padding: 24px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .toolbar {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            justify-content: center;
            margin-bottom: 20px;
            background: var(--c-surface-alt);
            padding: 12px;
            border-radius: var(--radius-md);
            width: 100%;
        }

        .tool-btn {
            width: 44px;
            height: 44px;
            border-radius: 8px;
            border: 2px solid transparent;
            background: var(--c-surface);
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.2s;
            display: grid;
            place-items: center;
        }

        .tool-btn.active { border-color: var(--c-primary); color: var(--c-primary); background: #FFF7ED; }
        .tool-btn:hover:not(.active) { background: #E5E7EB; }

        .canvas-wrapper {
            position: relative;
            box-shadow: var(--shadow-md);
            border-radius: 8px;
            overflow: hidden;
            border: 4px solid var(--c-text-main);
            margin: 20px auto;
            background: white;
            /* Ensure cursor indicates action */
            cursor: crosshair;
            touch-action: none; /* Critical for drawing on mobile */
            max-width: 600px;
            width: 100%;
        }
        
        /* --- TOURNAMENT STYLES --- */
        .tournament-tab {
            background: linear-gradient(135deg, #D97706 0%, #F59E0B 100%);
            color: white !important;
            font-weight: 700;
        }
        
        .tournament-tab:hover {
            background: linear-gradient(135deg, #B45309 0%, #D97706 100%);
        }
        
        .tournament-container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .tournament-welcome {
            text-align: center;
            padding: 40px 20px;
        }
        
        .tournament-welcome h1 {
            font-size: 2.5rem;
            margin-bottom: 16px;
            color: var(--c-primary);
        }
        
        .tournament-btn {
            padding: 16px 32px;
            font-size: 1.1rem;
            font-weight: 700;
            border: none;
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: all 0.3s;
            background: var(--c-primary);
            color: white;
        }
        
        .tournament-btn:hover {
            background: var(--c-primary-hover);
            transform: translateY(-2px);
            box-shadow: var(--shadow-lg);
        }


        /* --- GALLERY GRID --- */
        .gallery-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 24px;
        }

        .art-card {
            background: var(--c-surface);
            border-radius: var(--radius-md);
            overflow: hidden;
            box-shadow: var(--shadow-sm);
            transition: transform 0.2s;
            border: 1px solid rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
        }

        .art-card:hover { transform: translateY(-4px); box-shadow: var(--shadow-lg); }

        .art-image {
            width: 100%;
            aspect-ratio: 4/3;
            object-fit: contain;
            background: white;
            border-bottom: 1px solid var(--c-surface-alt);
        }

        .art-info { padding: 16px; flex: 1; display: flex; flex-direction: column; }
        .art-title { font-weight: 700; margin-bottom: 4px; font-size: 1.1rem; }
        .art-meta { color: var(--c-text-muted); font-size: 0.9rem; margin-bottom: 12px; display: flex; justify-content: space-between; }
        
        .vote-btn {
            margin-top: auto;
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            transition: background 0.2s;
        }

        .vote-btn.can-vote { background: var(--c-surface-alt); color: var(--c-text-main); }
        .vote-btn.can-vote:hover { background: var(--c-accent-rose); color: white; }
        
        .vote-btn.voted { background: var(--c-accent-teal); color: white; cursor: default; }
        .vote-btn.own-art { background: #E5E7EB; color: #9CA3AF; cursor: not-allowed; }

        /* --- INPUTS --- */
        .input-group { margin-bottom: 16px; width: 100%; max-width: 400px; text-align: left; }
        .input-label { display: block; margin-bottom: 6px; font-weight: 600; font-size: 0.9rem; }
        .form-control {
            width: 100%;
            padding: 10px 14px;
            border: 1px solid #D1D5DB;
            border-radius: 8px;
            font-size: 1rem;
            background: var(--c-surface);
            color: var(--c-text-main);
        }
        .form-control:focus { outline: 2px solid var(--c-primary); border-color: transparent; }

        /* --- NOTIFICATIONS --- */
        .toast {
            position: fixed;
            bottom: 24px;
            right: 24px;
            padding: 16px 24px;
            background: var(--c-text-main);
            color: white;
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-lg);
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            z-index: 1000;
        }
        .toast.show { transform: translateY(0); opacity: 1; }
        .toast.success { border-left: 4px solid var(--c-accent-teal); }
        .toast.error { border-left: 4px solid var(--c-accent-rose); }

        /* --- LEADERBOARD --- */
        .rank-row {
            display: flex;
            align-items: center;
            padding: 12px;
            border-bottom: 1px solid var(--c-surface-alt);
        }
        .rank-num { font-size: 1.5rem; font-weight: 800; width: 50px; text-align: center; color: var(--c-text-muted); }
        .rank-1 { color: #F59E0B; }
        .rank-2 { color: #9CA3AF; }
        .rank-3 { color: #B45309; }

        @media (max-width: 768px) {
            .hero h1 { font-size: 2rem; }
            .canvas-wrapper canvas { width: 100%; height: auto; touch-action: none; }
            .nav-tabs { overflow-x: auto; justify-content: flex-start; padding-bottom: 4px; }
            .nav-tab { white-space: nowrap; }
        }
        /* --- MODAL STYLES --- */
        .art-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.9);
            backdrop-filter: blur(5px);
            cursor: zoom-out;
        }

        .modal-content {
            margin: auto;
            display: block;
            max-width: 90%;
            max-height: 80vh;
            border: 5px solid white;
            border-radius: 8px;
            margin-top: 5vh;
            cursor: default;
        }

        .close-modal {
            position: absolute;
            top: 20px;
            right: 35px;
            color: #f1f1f1;
            font-size: 60px;
            font-weight: bold;
            cursor: pointer;
            line-height: 1;
        }

        .modal-caption {
            margin: auto;
            display: block;
            width: 80%;
            text-align: center;
            color: white;
            padding: 20px 0;
            font-size: 1.5rem;
            font-weight: bold;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>

    <header class="hero">
        <h1>üêæ Hand Drawn Dog Competition</h1>
        <p>Show off your artistic skills. Draw a dog, get votes, and become the top artist.</p>
        
        <div class="hero-stats">
            <span><strong id="statTotalDrawings">0</strong> Drawings</span>
            <span>‚Ä¢</span>
            <span><strong id="statTotalVotes">0</strong> Votes Cast</span>
        </div>

        <button class="btn-cta" onclick="activateTab('draw')">‚úèÔ∏è Start Drawing Now</button>
    </header>

    <nav class="nav-container">
    <div class="nav-tabs">
        <button class="nav-tab active" onclick="activateTab('draw')">Draw</button>
        <button class="nav-tab" onclick="activateTab('gallery')">Gallery</button>
        <button class="nav-tab" onclick="activateTab('leaderboard')">Leaderboard</button>
        <button class="nav-tab" onclick="activateTab('accuracy')">Accuracy</button>
        <button class="nav-tab tournament-tab" onclick="activateTab('tournament')">üèÜ Tournament</button>
    </div>
</nav>


    <div class="container">
        
        <div id="draw" class="tab-content active">
            <div class="input-group">
                <label class="input-label">1. Give Your Drawing a Title</label>
                <input type="text" id="dogTitle" class="form-control" placeholder="Your Dog Title" maxlength="50">
            </div>

            <div class="input-group">
                <label class="input-label">Choose a Reference (Optional)</label>
                <select id="refSelect" class="form-control">
                    <option value="">Select a dog photo...</option>
                </select>
            </div>

            <div class="toolbar">
                <button class="tool-btn active" id="btnPen" title="Pen">üñäÔ∏è</button>
                <button class="tool-btn" id="btnBrush" title="Brush">üñåÔ∏è</button>
                <button class="tool-btn" id="btnCalligraphy" title="Calligraphy">üñãÔ∏è</button>
                <button class="tool-btn" id="btnEraser" title="Eraser">üßπ</button>
                <button class="tool-btn" id="btnFill" title="Fill">ü™£</button>
                
                <div style="width: 1px; background: #ddd; margin: 0 8px;"></div>
                
                <input type="color" id="colorPicker" value="#000000" style="height: 44px; width: 44px; padding: 0; border: none; cursor: pointer;">
                
                <div style="width: 1px; background: #ddd; margin: 0 8px;"></div>
                
                <div style="display: flex; flex-direction: column; align-items: center; gap: 2px;">
                    <span style="font-size: 0.7rem; font-weight: bold; color: var(--c-text-muted);">SIZE</span>
                    <input type="range" id="sizeSlider" min="1" max="50" value="5" style="width: 80px; cursor: pointer;">
                </div>
                
                <div style="width: 1px; background: #ddd; margin: 0 8px;"></div>
                
                <button class="tool-btn" id="btnUndo" title="Undo">‚Ü∂</button>
                <button class="tool-btn" id="btnClear" title="Clear">üóëÔ∏è</button>
            </div>

            <div class="canvas-wrapper">
                <canvas id="refCanvas" width="600" height="450" style="position: absolute; pointer-events: none; opacity: 0;"></canvas>
                <canvas id="overlayCanvas" width="600" height="450" style="position: absolute; pointer-events: none; top:0; left:0;"></canvas>
                <div id="tournamentStatusHeader" style="display:none; width:100%; background:var(--c-primary); color:white; padding:10px; border-radius:8px 8px 0 0; text-align:center; font-weight:bold; margin-bottom:-4px;">
                    üèÜ HDD TOURNAMENT MODE: <span id="tournamentRoundName">Round 1</span> - <span id="tournamentTimeDisplay">03:00</span>
                </div>
                <canvas id="drawCanvas" width="600" height="450"></canvas>
            </div>

            <div class="input-group" style="display: flex; gap: 10px; align-items: flex-end; margin-top: 20px;">
                <div style="flex: 1;">
                    <label class="input-label">2. Sign your Masterpiece</label>
                    <input type="text" id="artistName" class="form-control" placeholder="Your Artist Name" maxlength="30">
                </div>
                <button class="btn-cta" id="btnSubmit" style="padding: 10px 24px; font-size: 1rem;">Publish</button>
            </div>
            
            <div style="margin-top: 10px;">
                    <label style="font-size: 0.9rem; color: var(--c-text-muted);">
                    <input type="checkbox" id="toggleRef" disabled> Show Reference Overlay
                </label>
                <input type="range" id="opacitySlider" min="0" max="100" value="30" disabled style="vertical-align: middle;">
            </div>
        </div>

        <div id="gallery" class="tab-content">
            <div style="margin-bottom: 20px; display: flex; justify-content: space-between; align-items: center;">
                <h2>Latest Submissions</h2>
                <span style="font-size: 0.9rem; color: var(--c-text-muted);">Sorted by Popularity</span>
            </div>
            <div id="galleryGrid" class="gallery-grid"></div>
        </div>

        <div id="leaderboard" class="tab-content">
            <div class="drawing-card" style="align-items: stretch; max-width: 800px; margin: 0 auto;">
                <h2 style="text-align: center; margin-bottom: 20px;">üèÜ Hall of Fame</h2>
                <div id="leaderboardList"></div>
            </div>
        </div>

        <div id="accuracy" class="tab-content">
            <div class="drawing-card" style="align-items: stretch; max-width: 800px; margin: 0 auto;">
                <h2 style="text-align: center; margin-bottom: 10px;">üéØ Smart Accuracy Scores</h2>
                <p style="text-align: center; color: var(--c-text-muted); margin-bottom: 30px;">
                    Our algorithm analyzes color matching and shape composition.
                </p>
                <div id="accuracyList"></div>
            </div>
        </div>

        <div class="tab-content" id="tournament">
            <div class="tournament-container">
               <div id="tournamentWelcome" class="tournament-welcome">
    <h1>üèÜ Tournament Mode</h1>
    
    <div style="max-width: 400px; margin: 0 auto 30px; background: var(--c-surface); padding: 20px; border-radius: var(--radius-md); box-shadow: var(--shadow-md); border: 2px solid var(--c-primary);">
        <label class="input-label" style="text-align: center; display: block; font-size: 1.1rem;">What is the artist's name?</label>
        <input type="text" id="tournamentArtistName" class="form-control" placeholder="Your artist name..." maxlength="25" style="text-align: center; font-size: 1.2rem; border-color: var(--c-primary);">
    </div>

    <p style="font-size: 1rem; color: var(--c-text-muted); margin-bottom: 20px;">
        Compete against others in a real-time drawing battle!
    </p>
    
    <button class="tournament-btn" onclick="startTournamentLobby()" style="width: 100%; max-width: 400px; margin-bottom: 15px;">
        ‚ö° Start New Tournament
    </button>

    <div style="margin-top: 10px;">
        <div style="display: flex; gap: 8px; justify-content: center; flex-wrap: wrap; max-width: 400px; margin: 0 auto;">
            <input id="joinLobbyCodeInput" placeholder="CODE" style="flex: 1; padding: 12px; border-radius: 8px; border: 1px solid #ddd; text-transform: uppercase; font-weight: bold; text-align: center;">
            <button class="tournament-btn" style="padding: 10px 20px;" onclick="joinExistingLobby()">
                üîë Join Code
            </button>
        </div>
    </div>
</div>
                    
                    <div style="margin-top: 32px; padding: 20px; background: var(--c-surface-alt); border-radius: var(--radius-md);">
                        <h3>üìã How it works:</h3>
                        <ul style="text-align: left; max-width: 500px; margin: 16px auto; line-height: 1.8;">
                            <li>üéØ 2‚Äì4 players per tournament</li>
                            <li>‚è±Ô∏è Lobby starts in 3 minutes (or with 4 players)</li>
                            <li>üé® 3 minutes per round to draw</li>
                            <li>üèÖ With 3 players: top 2 go to the finals</li>
                            <li>üèÜ Winner enters the Hall of Fame</li>
                        </ul>
                    </div>
                </div>
                
                <div id="tournamentLobby" style="display:none;"></div>
                <div id="tournamentDrawing" style="display:none;"></div>
                <div id="tournamentResults" style="display:none;"></div>
                <div id="tournamentHallOfFame" style="margin-top: 32px; display:none;">
                    <h3>üèÜ Tournament Hall of Fame</h3>
                    <div id="tournamentHallOfFameList"></div>
                </div>
            </div>
        </div>
    </div>
<div id="artModal" class="art-modal" onclick="closeModal()">
    <span class="close-modal">&times;</span>
    <img class="modal-content" id="modalImg" onclick="event.stopPropagation()">
    <div id="modalCaption" class="modal-caption"></div>
    <div style="text-align:center; margin-top: 10px;">
        <button class="btn-cta" id="downloadArtBtn" onclick="event.stopPropagation(); downloadCanvasImage();" style="padding: 10px 20px; font-size: 0.9rem; background: var(--c-accent-teal);">
    üíæ Download Drawing
</button>
    </div>
</div>    <div id="toast" class="toast"></div>

    <script>
        // Initialise client global
        const SUPABASE_URL = "https://vxfzjzsshwxrqherfmfh.supabase.co";
        const SUPABASE_KEY = "sb_publishable_GOuAPSxNwfuzU1lxVxi4Dw_qN7kY-Xz"; // Note: Ensure this is your public key
        const client = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
// --- CONFIG & STATE ---
        const CONFIG = {
            width: 600,
            height: 450,
            dogs: [
                { name: 'Dawg w the glasses', url: 'https://images.unsplash.com/photo-1554224311-beee415c201f?q=80&w=735&auto=format&fit=crop' },
                { name: 'I don\'t know', url: 'https://i.imgur.com/HQLadRP.jpeg' },
                { name: 'Side eye', url: 'https://i.imgur.com/beATevY.jpeg' },
                { name: 'Banana dog', url: 'https://images.unsplash.com/photo-1701445175220-1f485a27fb41?w=600&auto=format&fit=crop' },
                { name: 'Me after a big night out', url: 'https://i.imgur.com/jMb90Nw.png' },
                { name: 'Fluff', url: 'https://images.unsplash.com/photo-1505628346881-b72b27e84530?q=80&w=687&auto=format&fit=crop' },
                { name: 'Thug', url: 'https://i.imgur.com/8hkxbUv.png' },
                { name: 'Annoying shit', url: 'https://images.unsplash.com/photo-1583511655826-05700d52f4d9?q=80&w=688&auto=format&fit=crop' },
                { name: 'Murica', url: 'https://images.unsplash.com/photo-1422565096762-bdb997a56a84?q=80&w=1470&auto=format&fit=crop' },
                { name: 'The mrs', url: 'https://i.imgur.com/ku6rbCA.jpeg' },
                { name: 'HDD sellers once we hit 10MM', url: 'https://i.imgur.com/il8TKhA.jpeg' },
                // Let op: De link hieronder werkt waarschijnlijk niet (geen .jpg/.png), maar de syntax is nu wel geldig:
                { name: 'Twister', url: 'https://imgur.com/f466f1c7-3a3c-4c31-adb3-d1493dfd2be4' },
                { name: 'Why so serious?', url: 'https://images.unsplash.com/photo-1566710582818-d673dc761201?q=80&w=687&auto=format&fit=crop' }
            ]
        };
        const STATE = {
            drawings: [],
            myVotes: new Set(),
            tool: 'pen',
            color: '#000000',
            baseLineWidth: 5,
            history: [],
            historyStep: -1,
            refImage: null,
            // New State for Smooth Drawing
            points: [],
            isDrawing: false
        };

        // --- DOM ELEMENTS ---
        const canvas = document.getElementById('drawCanvas');
        const ctx = canvas.getContext('2d', { willReadFrequently: true });
        const refCanvas = document.getElementById('refCanvas');
        const refCtx = refCanvas.getContext('2d', { willReadFrequently: true });
        const overlayCanvas = document.getElementById('overlayCanvas');
        const overlayCtx = overlayCanvas.getContext('2d');

        // --- INITIALIZATION ---
        function init() {
            const storedVotes = localStorage.getItem('hddc_votes');
            
            // Setup Canvas Defaults
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            // Fill white background initially
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            saveHistory();

            // Populate Dropdown
            const select = document.getElementById('refSelect');
            if (select) {
                CONFIG.dogs.forEach((dog, i) => {
                    const opt = document.createElement('option');
                    opt.value = i;
                    opt.text = dog.name;
                    select.appendChild(opt);
                });
            }
            // Update Stats
            if (storedVotes) STATE.myVotes = new Set(JSON.parse(storedVotes));
        }

        // --- ADVANCED DRAWING ENGINE ---
        
        // Helper to get coordinates relative to canvas
        function getPointerPos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return { 
                x: (e.clientX - rect.left) * scaleX, 
                y: (e.clientY - rect.top) * scaleY,
                pressure: e.pressure || 0.5 // Default pressure if not supported
            };
        }

        // Start Drawing
        canvas.addEventListener('pointerdown', (e) => {
            e.preventDefault(); // Prevent scrolling on touch
            canvas.setPointerCapture(e.pointerId);
            
            STATE.isDrawing = true;
            const pos = getPointerPos(e);
            
            // If tool is fill, do fill and exit
            if(STATE.tool === 'fill') {
                floodFill(Math.floor(pos.x), Math.floor(pos.y), STATE.color);
                STATE.isDrawing = false;
                saveHistory();
                return;
            }

            // Start new stroke
            STATE.points = [];
            STATE.points.push(pos);
            
            ctx.beginPath();
            ctx.moveTo(pos.x, pos.y);
            
            // If it's a dot
            if (STATE.tool !== 'eraser') {
                 // Initial dot
                 const pressureWidth = getLineWidth(pos.pressure);
                 ctx.fillStyle = STATE.color;
                 ctx.beginPath();
                 ctx.arc(pos.x, pos.y, pressureWidth/2, 0, Math.PI * 2);
                 ctx.fill();
            }
        });

        // Move Drawing
        canvas.addEventListener('pointermove', (e) => {
            if (!STATE.isDrawing) return;
            e.preventDefault();
            
            const pos = getPointerPos(e);
            STATE.points.push(pos);

            if (STATE.points.length < 3) {
                const b = STATE.points[0];
                ctx.beginPath();
                ctx.arc(b.x, b.y, ctx.lineWidth / 2, 0, Math.PI * 2, !0);
                ctx.fill();
                ctx.closePath();
                return;
            }

            const p1 = STATE.points[STATE.points.length - 3];
            const p2 = STATE.points[STATE.points.length - 2];
            const p3 = STATE.points[STATE.points.length - 1];

            // Quadratic Bezier for smoothness
            const mid1 = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
            const mid2 = { x: (p2.x + p3.x) / 2, y: (p2.y + p3.y) / 2 };

            ctx.beginPath();
            ctx.moveTo(mid1.x, mid1.y);
            ctx.quadraticCurveTo(p2.x, p2.y, mid2.x, mid2.y);

            // Dynamic Styling based on tool
            const pressure = p2.pressure;
            let width = getLineWidth(pressure);
            
            if (STATE.tool === 'eraser') {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.lineWidth = width * 2; // Eraser is bigger
            } else {
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = STATE.color;
                ctx.lineWidth = width;
            }
            
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.stroke();
        });

        // End Drawing
        canvas.addEventListener('pointerup', (e) => {
            if (STATE.isDrawing) {
                STATE.isDrawing = false;
                ctx.globalCompositeOperation = 'source-over'; // Reset
                saveHistory();
            }
        });
        
        // Determine line width based on tool & pressure
        function getLineWidth(pressure) {
            const base = parseInt(STATE.baseLineWidth);
            
            if (STATE.tool === 'pen') {
                // Pen: slight variation, mostly consistent
                return Math.max(1, base * (0.5 + pressure * 0.5));
            } 
            else if (STATE.tool === 'brush') {
                // Brush: Heavy variation
                return Math.max(1, base * (pressure * 1.5));
            }
            else if (STATE.tool === 'calligraphy') {
                 // Calligraphy: Inverse logic? Or just simplified
                 return Math.max(1, base); 
            }
            return base; // Eraser uses base * 2 in logic
        }

        // --- FLOOD FILL ---
        function floodFill(x, y, hexColor) {
            const imgData = ctx.getImageData(0,0,canvas.width,canvas.height);
            const data = imgData.data;
            const targetColor = getPixel(data, x, y);
            const fillColor = hexToRgb(hexColor);
            
            if(colorsMatch(targetColor, fillColor)) return;

            // Simple Stack based fill
            const stack = [[x, y]];
            // Safety break
            let loops = 0;
            const maxLoops = canvas.width * canvas.height;

            while(stack.length && loops < maxLoops) {
                loops++;
                const [cx, cy] = stack.pop();
                if(cx < 0 || cx >= canvas.width || cy < 0 || cy >= canvas.height) continue;
                
                const current = getPixel(data, cx, cy);
                if(colorsMatch(current, targetColor)) {
                    setPixel(data, cx, cy, fillColor);
                    stack.push([cx+1, cy], [cx-1, cy], [cx, cy+1], [cx, cy-1]);
                }
            }
            ctx.putImageData(imgData, 0, 0);
        }
        
        function getPixel(data, x, y) {
            const i = (y * canvas.width + x) * 4;
            return {r: data[i], g: data[i+1], b: data[i+2]};
        }
        
        function setPixel(data, x, y, c) {
            const i = (y * canvas.width + x) * 4;
            data[i] = c.r; data[i+1] = c.g; data[i+2] = c.b; data[i+3] = 255;
        }
        
        function colorsMatch(c1, c2) {
            // Tolerance of 10 for anti-aliasing edges
            return Math.abs(c1.r - c2.r) < 30 && Math.abs(c1.g - c2.g) < 30 && Math.abs(c1.b - c2.b) < 30;
        }
        
        function hexToRgb(hex) {
            const r = parseInt(hex.substr(1,2), 16);
            const g = parseInt(hex.substr(3,2), 16);
            const b = parseInt(hex.substr(5,2), 16);
            return {r,g,b};
        }

        // --- HISTORY ---
        function saveHistory() {
            STATE.historyStep++;
            STATE.history = STATE.history.slice(0, STATE.historyStep);
            STATE.history.push(canvas.toDataURL());
            // Limit history to save memory
            if(STATE.history.length > 20) { STATE.history.shift(); STATE.historyStep--; }
        }

        function undo() {
            if(STATE.historyStep > 0) {
                STATE.historyStep--;
                const img = new Image();
                img.src = STATE.history[STATE.historyStep];
                img.onload = () => {
                    ctx.clearRect(0,0,canvas.width,canvas.height);
                    ctx.drawImage(img,0,0);
                }
            }
        }

        // --- REFERENCE IMAGE LOGIC ---
        const refSelectElement = document.getElementById('refSelect');
        if (refSelectElement) {
            refSelectElement.addEventListener('change', function(e) {
                const val = e.target.value;
                
                // Reset if no selection
                if(val === "") {
                    STATE.refImage = null;
                    refCtx.fillStyle = '#FFFFFF';
                    refCtx.fillRect(0, 0, canvas.width, canvas.height);
                    document.getElementById('toggleRef').disabled = true;
                    document.getElementById('toggleRef').checked = false;
                    document.getElementById('opacitySlider').disabled = true;
                    updateOverlay();
                    return;
                }

                const selectedIndex = parseInt(val);
                const dog = CONFIG.dogs[selectedIndex];
                
                if(!dog) return;
                
                const img = new Image();
                img.crossOrigin = "Anonymous"; 
                img.src = dog.url;
                
                img.onload = () => {
                    STATE.refImage = img;
                    
                    // Scale dog image to canvas
                    const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
                    const w = img.width * scale;
                    const h = img.height * scale;
                    const x = (canvas.width - w) / 2;
                    const y = (canvas.height - h) / 2;
                    
                    refCtx.fillStyle = '#FFFFFF';
                    refCtx.fillRect(0, 0, canvas.width, canvas.height);
                    refCtx.drawImage(img, x, y, w, h);
                    
                    // Activate controls
                    const toggleRef = document.getElementById('toggleRef');
                    const opacitySlider = document.getElementById('opacitySlider');
                    
                    toggleRef.disabled = false;
                    toggleRef.checked = true; 
                    opacitySlider.disabled = false;
                    
                    updateOverlay();
                };

                img.onerror = () => {
                    console.error('Could not load image:', dog.url);
                    showToast('Could not load reference image.', 'error');
                };
            });
        }

        function updateOverlay() {
            overlayCtx.clearRect(0,0,canvas.width, canvas.height);
            if(document.getElementById('toggleRef').checked && STATE.refImage) {
                const opacity = document.getElementById('opacitySlider').value / 100;
                overlayCtx.globalAlpha = opacity;
                overlayCtx.drawImage(refCanvas, 0, 0);
            }
        }

        // --- ACCURACY ALGO ---
        function calculateAccuracy() {
            if(!STATE.refImage) return { total: 0, color: 0, shape: 0 };

            const dData = ctx.getImageData(0,0,canvas.width,canvas.height).data;
            const rData = refCtx.getImageData(0,0,canvas.width,canvas.height).data;
            
            let matchColor = 0, matchShape = 0, totalContent = 0;

            for(let i=0; i<dData.length; i+=16) {
                const rR=rData[i], rG=rData[i+1], rB=rData[i+2];
                const dR=dData[i], dG=dData[i+1], dB=dData[i+2];

                const isRefContent = (rR < 250 || rG < 250 || rB < 250);
                const isDrawContent = (dR < 250 || dG < 250 || dB < 250);

                if(isRefContent) {
                    totalContent++;
                    if(isDrawContent) {
                        matchShape++;
                        const diff = Math.abs(rR-dR) + Math.abs(rG-dG) + Math.abs(rB-dB);
                        if(diff < 100) matchColor++;
                    }
                }
            }

            if(totalContent === 0) return { total: 0 };
            
            const shapeScore = (matchShape / totalContent) * 100;
            const colorScore = matchShape > 0 ? (matchColor / matchShape) * 100 : 0;
            const total = (shapeScore * 0.6) + (colorScore * 0.4);

            return {
                total: Math.round(total),
                shape: Math.round(shapeScore),
                color: Math.round(colorScore)
            };
        }

        // --- SUBMIT & VOTE ---
        function vote(id) {
            const drawing = STATE.drawings.find(d => d.id === id);
            
            if(!drawing) return;
            if(STATE.myVotes.has(id)) {
                showToast('You already voted for this!', 'error');
                return;
            }
            if(drawing.isLocal) {
                showToast('You cannot vote for your own art!', 'error');
                return;
            }

            drawing.votes++;
            STATE.myVotes.add(id);
            saveData();
            showToast('Vote cast! ‚ù§Ô∏è', 'success');
            renderGallery(); 
            updateGlobalStats();
        }

        // --- RENDERING ---
        function renderGallery() {
            const grid = document.getElementById('galleryGrid');
            const sorted = [...STATE.drawings].sort((a, b) => {
                if (b.votes !== a.votes) return b.votes - a.votes;
                return b.timestamp - a.timestamp;
            });

            grid.innerHTML = sorted.map(d => {
                const isVoted = STATE.myVotes.has(d.id);
                const isOwn = d.isLocal === true;
                
                let btnClass = 'can-vote';
                let btnText = '‚ù§Ô∏è Vote';
                let btnAction = `onclick="event.stopPropagation(); vote(${d.id})"`;
                
                if (isOwn) {
                    btnClass = 'own-art';
                    btnText = 'üë§ Your Art';
                    btnAction = 'onclick="event.stopPropagation();"';
                } else if (isVoted) {
                    btnClass = 'voted';
                    btnText = '‚úÖ Voted';
                    btnAction = 'onclick="event.stopPropagation();"';
                }

                return `
                <div class="art-card" onclick="openModal('${d.image}', '${escapeHtml(d.artist)}')">
                    <img src="${d.image}" class="art-image" style="cursor: zoom-in;">
                    <div class="art-info">
                        <div class="art-title">${escapeHtml(d.artist)}</div>
                        <div class="art-meta">
                            <span>‚ù§Ô∏è ${d.votes}</span>
                            <span>Score: ${d.scores.total || 0}%</span>
                        </div>
                        <button class="vote-btn ${btnClass}" ${btnAction}>
                            ${btnText}
                        </button>
                    </div>
                </div>`;
            }).join('');
        }

        function renderLeaderboard() {
            const list = document.getElementById('leaderboardList');
            const sorted = [...STATE.drawings].sort((a, b) => b.votes - a.votes).slice(0, 10);
            
            if(sorted.length === 0) {
                list.innerHTML = '<div style="text-align:center; padding:20px;">No drawings yet. Be the first!</div>';
                return;
            }

            list.innerHTML = sorted.map((d, i) => `
                <div class="rank-row">
                    <div class="rank-num rank-${i+1}">${i+1}</div>
                    <img src="${d.image}" style="width: 50px; height: 50px; object-fit: cover; border-radius: 4px; border:1px solid #eee;">
                    <div style="margin-left: 15px; flex: 1;">
                        <div style="font-weight:700;">${escapeHtml(d.artist)}</div>
                        <div style="font-size:0.8rem; color:#666;">${d.votes} Votes</div>
                    </div>
                </div>
            `).join('');
        }

        function renderAccuracy() {
            const list = document.getElementById('accuracyList');
            const sorted = [...STATE.drawings]
                .filter(d => d.scores.total > 0)
                .sort((a, b) => b.scores.total - a.scores.total)
                .slice(0, 10);

            if(sorted.length === 0) {
                list.innerHTML = '<div style="text-align:center; padding:20px;">Use a reference photo to get a Smart Score!</div>';
                return;
            }

            list.innerHTML = sorted.map((d, i) => `
                <div class="rank-row">
                    <div class="rank-num rank-${i+1}">${i+1}</div>
                    <img src="${d.image}" style="width: 50px; height: 50px; object-fit: cover; border-radius: 4px; border:1px solid #eee;">
                    <div style="margin-left: 15px; flex: 1;">
                        <div style="font-weight:700;">${escapeHtml(d.artist)}</div>
                        <div style="font-size:0.8rem; color:#666;">
                            Total: <strong>${d.scores.total}%</strong> 
                            (Color: ${d.scores.color}% | Shape: ${d.scores.shape}%)
                        </div>
                    </div>
                </div>
            `).join('');
        }

        // --- TOURNAMENT LOBBY SYSTEM ---
        const LOBBY = {
            state: {
                tournamentId: null,
                playerId: null,
                playerName: '',
                checkInterval: null
            },
            generateCode() {
                const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
                let code = '';
                for (let i = 0; i < 6; i++) {
                    code += chars[Math.floor(Math.random() * chars.length)];
                }
                return code;
            },
            async createNewLobby() {
                try {
                    const lobbyCode = this.generateCode();
                    const randomDog = Math.floor(Math.random() * CONFIG.dogs.length);
                    const { data: tournament, error } = await client
                        .from('tournaments')
                        .insert([{
                            lobby_code: lobbyCode,
                            reference_dog_id: randomDog,
                            max_players: 4,
                            draw_time_seconds: 180,
                            status: 'waiting'
                        }])
                        .select()
                        .single();
                    if (error) throw error;
                    this.state.tournamentId = tournament.id;
                    return tournament;
                } catch (err) {
                    console.error('Error creating lobby:', err);
                    showToast('Error creating lobby', 'error');
                    return null;
                }
            },
            async addPlayerToLobby(tournament, playerName) {
                try {
                    const { data: existingPlayers } = await client
                        .from('tournament_players')
                        .select('player_slot')
                        .eq('tournament_id', tournament.id);

                    let slot = 0;
                    if (existingPlayers && existingPlayers.length > 0) {
                        const usedSlots = existingPlayers.map(p => p.player_slot);
                        while (usedSlots.includes(slot)) { slot++; }
                    }

                    const { data: player, error } = await client
                        .from('tournament_players')
                        .insert([{
                            tournament_id: tournament.id,
                            player_slot: slot,
                            is_eliminated: false,
                            current_round: 1,
                            player_name: playerName
                        }])
                        .select()
                        .single();

                    if (error) throw error;
                    this.state.playerId = player.id;
                    this.state.playerName = playerName;
                    return player;
                } catch (err) {
                    console.error('Error adding player:', err);
                    showToast('Error joining lobby', 'error');
                    return null;
                }
            },
            async getPlayersInLobby(tournamentId) {
                try {
                    const { data: players, error } = await client
                        .from('tournament_players')
                        .select('*')
                        .eq('tournament_id', tournamentId)
                        .order('player_slot');
                    
                    if (error) throw error;
                    return players || [];
                } catch (err) {
                    console.error('Error fetching players:', err);
                    return [];
                }
            },
            showLobbyUI(tournament, players) {
                const welcome = document.getElementById('tournamentWelcome');
                const lobby = document.getElementById('tournamentLobby');

                if (!welcome || !lobby) return;

                welcome.style.display = 'none';
                lobby.style.display = 'block';

               lobby.innerHTML = `
                    <div class="lobby-waiting">
                        <h1>üéÆ Waiting Lobby</h1>
                        <div class="lobby-code-display">
                            <p style="margin: 0 0 8px 0; color: var(--c-text-muted);">Lobby Code:</p>
                            <div class="code-big" style="font-size: 3rem; font-weight:800; letter-spacing: 5px; color: var(--c-primary);">${tournament.lobby_code}</div>
                        </div>

                        <div id="lobbyCountdown" class="countdown-display" style="margin-top:20px; background: #FEF3C7; padding: 15px; border-radius: 8px; border: 2px solid #F59E0B;">
                            <h3 style="color: #92400E; text-align:center;">
                                ‚è≥ Tournament starts in: <span id="lobbyCountdownSeconds">180</span>s
                            </h3>
                        </div>

                        <h3 style="text-align: center; margin: 16px 0;">
                            Players: <span id="playerCount">1</span>/4
                        </h3>
                        <div class="players-grid" id="playersGrid" style="display:flex; justify-content:center; gap:20px; margin-top:20px;"></div>

                        <p style="text-align: center; color: var(--c-text-muted); margin-top: 24px;">
                            Wait for a minimum of 2 dawgs...
                        </p>
                    </div>
                `;

                this.updatePlayersGrid(players);
                this.startLobbyCountdown(tournament);
            },
            updatePlayersGrid(players) {
                const grid = document.getElementById('playersGrid');
                const countEl = document.getElementById('playerCount');
                if (!grid || !countEl) return;

                const slots = [0, 1, 2, 3];
                grid.innerHTML = slots.map(slot => {
                    const player = players.find(p => p.player_slot === slot);
                    if (player) {
                        return `
                            <div class="player-slot filled" style="background:var(--c-surface); padding:15px; border-radius:8px; text-align:center; box-shadow:var(--shadow-sm);">
                                <div style="font-size: 2rem; margin-bottom: 8px;">üë§</div>
                                <div style="font-weight: 700;">${escapeHtml(player.player_name)}</div>
                                <div style="font-size: 0.85rem; margin-top: 4px;">Joined</div>
                            </div>
                        `;
                    } else {
                        return `
                            <div class="player-slot empty" style="background:var(--c-surface-alt); padding:15px; border-radius:8px; text-align:center; opacity:0.7;">
                                <div style="font-size: 2rem; margin-bottom: 8px; opacity: 0.3;">üë§</div>
                                <div style="font-weight: 600; color: var(--c-text-muted);">Waiting...</div>
                            </div>
                        `;
                    }
                }).join('');

                countEl.textContent = players.length.toString();
            },
            startLobbyPolling() {
                if (this.state.checkInterval) {
                    clearInterval(this.state.checkInterval);
                }

                this.state.checkInterval = setInterval(async () => {
                    if (!this.state.tournamentId) return;

                    const players = await this.getPlayersInLobby(this.state.tournamentId);
                    this.updatePlayersGrid(players);

                    // If 4 players: start immediately
                    if (players.length === 4) {
                        clearInterval(this.state.checkInterval);
                        this.state.checkInterval = null;
                        startTournamentFromLobby();
                    }
                }, 1500);
            },
            startLobbyCountdown(tournament) {
                const countdownEl = document.getElementById('lobbyCountdown');
                const secondsEl = document.getElementById('lobbyCountdownSeconds');
                if (!countdownEl || !secondsEl) return;

                countdownEl.style.display = 'block';
                let remaining = 180; // 3 minutes

                if (this.state.lobbyCountdownInterval) {
                    clearInterval(this.state.lobbyCountdownInterval);
                }

                this.state.lobbyCountdownInterval = setInterval(async () => {
                    remaining--;
                    if (remaining < 0) remaining = 0;
                    secondsEl.textContent = remaining.toString();

                    if (remaining <= 0) {
                        clearInterval(this.state.lobbyCountdownInterval);

                        if (!this.state.tournamentId) return;
                        const players = await this.getPlayersInLobby(this.state.tournamentId);

                        if (players.length >= 2) {
                            showToast('Lobby time over. Starting...', 'success');
                            startTournamentFromLobby();
                        } else {
                            showToast('Not enough players to start the tournament', 'error');
                        }
                    }
                }, 1000);
            }
        };

        // --- TOURNAMENT LOGIC ---
        const TOURNAMENT_DRAW_TIME_SECONDS = 180;
        const TOURNAMENT = {
            currentRound: 0,
            totalRounds: 0,
            players: [],          
            finalists: [],        
            winner: null,
            roundTimerId: null,
            roundTimeLeft: TOURNAMENT_DRAW_TIME_SECONDS,
            referenceDogIndex: null
        };

        async function startTournamentLobby() {
            const nameInput = document.getElementById('tournamentArtistName');
            const playerName = nameInput ? nameInput.value.trim() : '';

            if (!playerName || playerName === '' || playerName === 'Anonymous') {
                showToast('Enter your dawg name', 'error');
                return;
            }

            LOBBY.state.playerName = playerName;
            document.getElementById('artistName').value = playerName;

            try {
                const tournament = await LOBBY.createNewLobby();
                if (!tournament) return;

                LOBBY.state.tournamentId = tournament.id;
                const player = await LOBBY.addPlayerToLobby(tournament, playerName);
                if (!player) return;

                LOBBY.showLobbyUI(tournament, [player]);
                LOBBY.startLobbyPolling();
            } catch (err) {
                console.error(err);
                showToast('Error starting tournament lobby', 'error');
            }
        }

        async function startTournamentFromLobby() {
            if (LOBBY.state.checkInterval) { 
                clearInterval(LOBBY.state.checkInterval); 
                LOBBY.state.checkInterval = null; 
            }
            if (LOBBY.state.lobbyCountdownInterval) { 
                clearInterval(LOBBY.state.lobbyCountdownInterval); 
                LOBBY.state.lobbyCountdownInterval = null; 
            }
            
            const lobbyCountdown = document.getElementById('lobbyCountdown');
            if (lobbyCountdown) lobbyCountdown.style.display = 'none';

            try {
                if (!LOBBY.state.tournamentId) return;

                const players = await LOBBY.getPlayersInLobby(LOBBY.state.tournamentId);
                TOURNAMENT.players = players;

                const { data: tournament, error } = await client
                    .from('tournaments')
                    .select('id, status')
                    .eq('id', LOBBY.state.tournamentId)
                    .single();

                if (error || !tournament) {
                    showToast('Could not start tournament', 'error');
                    return;
                }

                const nowIso = new Date().toISOString();
                const { error: updateError } = await client
                    .from('tournaments')
                    .update({
                        status: 'active',
                        started_at: nowIso,
                        current_round: 1,
                        round_started_at: nowIso
                    })
                    .eq('id', LOBBY.state.tournamentId);

                if (updateError) throw updateError;

                showToast('Tournament started!', 'success');
                beginTournamentRounds(); 
            } catch (err) {
                console.error(err);
                showToast('Error starting tournament', 'error');
            }
        }

        async function joinExistingLobby() {
            const nameInput = document.getElementById('tournamentArtistName');
            const playerName = nameInput ? nameInput.value.trim() : '';
            
            if (!playerName || playerName === '' || playerName === 'Anonymous') {
                showToast('Please fill in your artist name first!', 'error');
                return;
            }
            LOBBY.state.playerName = playerName;
            document.getElementById('artistName').value = playerName;    

            try {
                const input = document.getElementById('joinLobbyCodeInput');
                if (!input) return;

                const code = input.value.trim().toUpperCase();
                if (!code) {
                    showToast('Enter a lobby code', 'error');
                    return;
                }

                const { data: tournament, error } = await client
                    .from('tournaments')
                    .select('*')
                    .eq('lobby_code', code)
                    .eq('status', 'waiting')
                    .single();

                if (error || !tournament) {
                    showToast('Dawg cant be found, woof', 'error');
                    return;
                }

                const player = await LOBBY.addPlayerToLobby(tournament, playerName);
                if (!player) return;

                LOBBY.state.tournamentId = tournament.id;
                const players = await LOBBY.getPlayersInLobby(tournament.id);
                LOBBY.showLobbyUI(tournament, players);
                LOBBY.startLobbyPolling();
            } catch (err) {
                console.error(err);
                showToast('Error joining lobby', 'error');
            }
        }

        function beginTournamentRounds() {
            TOURNAMENT.currentRound = 1;
            const pCount = TOURNAMENT.players.length || 2; 
            TOURNAMENT.totalRounds = pCount > 2 ? 2 : 1;
            showTournamentDrawingRound();
        }

        function showTournamentDrawingRound() {
            const container = document.getElementById('tournamentDrawing');
            const welcome = document.getElementById('tournamentWelcome');
            const lobby = document.getElementById('tournamentLobby');
            const results = document.getElementById('tournamentResults');

            if (!container) return;
            if (welcome) welcome.style.display = 'none';
            if (lobby) lobby.style.display = 'none';
            if (results) results.style.display = 'none';

            container.style.display = 'block';

            TOURNAMENT.referenceDogIndex = Math.floor(Math.random() * CONFIG.dogs.length);
            const refDog = CONFIG.dogs[TOURNAMENT.referenceDogIndex];

            const refSelect = document.getElementById('refSelect');
            if (refSelect) {
                refSelect.value = TOURNAMENT.referenceDogIndex;
                const event = new Event('change');
                refSelect.dispatchEvent(event);
            }

            // Reset canvas
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            saveHistory();

            container.innerHTML = `
                <div class="drawing-card" style="align-items: stretch; max-width: 800px; margin: 0 auto;">
                    <h2 style="text-align:center; margin-bottom: 10px;">
                        ${buildTournamentRoundTitle()}
                    </h2>
                    <p style="text-align:center; color: var(--c-text-muted); margin-bottom: 10px;">
                        Reference: <strong>${refDog.name}</strong> ‚Äì You have 3 minutes to draw.
                    </p>
                    <p style="text-align:center; color: var(--c-text-muted); margin-bottom: 20px;">
                        Time left: <span id="tournamentRoundCountdown">180</span> seconds
                    </p>
                    <p style="text-align:center; color: var(--c-text-muted); margin-bottom: 20px;">
                        Use the drawing canvas in the "Draw" tab.
                    </p>
                </div>
            `;

            activateTab('draw');

            loadTournamentState().then(state => {
                if (!state || !state.round_started_at) {
                    startTournamentCountdownFromTimestamp(new Date().toISOString(), TOURNAMENT_DRAW_TIME_SECONDS);
                    return;
                }
                const duration = state.draw_time_seconds || TOURNAMENT_DRAW_TIME_SECONDS;
                startTournamentCountdownFromTimestamp(state.round_started_at, duration);
            });
        }

        async function loadTournamentState() {
            try {
                const { data } = await client
                    .from('tournaments')
                    .select('*')
                    .eq('id', LOBBY.state.tournamentId)
                    .single();
                return data;
            } catch (e) { return null; }
        }

        function startTournamentCountdownFromTimestamp(startTimeIso, durationSeconds) {
            const countdownEl = document.getElementById('tournamentRoundCountdown');
            const statusHeader = document.getElementById('tournamentStatusHeader');
            const roundNameEl = document.getElementById('tournamentRoundName');
            const timeDisplayEl = document.getElementById('tournamentTimeDisplay');
            
            const startTime = new Date(startTimeIso).getTime();
            const endTime = startTime + (durationSeconds * 1000);

            if (TOURNAMENT.roundTimerId) clearInterval(TOURNAMENT.roundTimerId);

            if (statusHeader) statusHeader.style.display = 'block';
            if (roundNameEl) roundNameEl.textContent = TOURNAMENT.currentRound === 1 && TOURNAMENT.players.length > 2 ? 'Qualification' : 'Final';

            TOURNAMENT.roundTimerId = setInterval(() => {
                const now = Date.now();
                const leftMs = endTime - now;
                let leftSec = Math.ceil(leftMs / 1000);

                if (leftSec < 0) leftSec = 0;

                if (countdownEl) countdownEl.textContent = leftSec;
                if (timeDisplayEl) {
                    const mins = Math.floor(leftSec / 60);
                    const secs = leftSec % 60;
                    timeDisplayEl.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
                }

                TOURNAMENT.roundTimeLeft = leftSec;

                if (leftSec <= 0) {
                    clearInterval(TOURNAMENT.roundTimerId);
                    if (statusHeader) statusHeader.style.display = 'none';
                    showToast('the dawg is done! Score is being calculated...', 'info');
                    onTournamentRoundEnd();
                }
            }, 1000);
        }

        function buildTournamentRoundTitle() {
            const players = TOURNAMENT.players.length;
            if (players === 2) return 'Final Round';
            if (players > 2 && TOURNAMENT.currentRound === 1) return 'Knock-out Round';
            return 'Final Round';
        }

        async function onTournamentRoundEnd() {
            const overlay = document.createElement('div');
            overlay.id = "roundEndOverlay";
            overlay.style = "position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.85); z-index:9999; display:flex; flex-direction:column; align-items:center; justify-content:center; color:white; font-family:sans-serif;";
            overlay.innerHTML = `<h1 style="font-size:4rem; margin-bottom:20px; animation: bounce 0.5s infinite;">‚åõ TIMES UP!</h1><p style="font-size:1.5rem;">A dawg is examining your work...</p>`;
            document.body.appendChild(overlay);

            setTimeout(() => {
                const el = document.getElementById('roundEndOverlay');
                if(el) el.remove();
                activateTab('tournament');
            }, 3000);

            try {
                const scores = calculateAccuracy(); 
                const totalScore = scores.total || 0;

                if (LOBBY.state.playerId && LOBBY.state.tournamentId) {
                    await client.from('tournament_rounds').insert([{
                        tournament_id: LOBBY.state.tournamentId,
                        player_id: LOBBY.state.playerId,
                        round_index: TOURNAMENT.currentRound,
                        total_score: totalScore,
                        color_score: scores.color || 0,
                        shape_score: scores.shape || 0,
                        reference_dog_index: TOURNAMENT.referenceDogIndex
                    }]);
                }
                await showTournamentResultsForCurrentRound();
            } catch (err) {
                console.error(err);
                showToast('Error saving tournament round score', 'error');
            }
        }

        async function showTournamentResultsForCurrentRound() {
            const container = document.getElementById('tournamentResults');
            const drawingView = document.getElementById('tournamentDrawing');
            
            if (!container) return;
            if (drawingView) drawingView.style.display = 'none';
            container.style.display = 'block';

            showToast('retrieving results...', 'info');
            await new Promise(r => setTimeout(r, 4000));

            const { data: roundScores, error } = await client
                .from('tournament_rounds')
                .select('*, tournament_players(player_name)')
                .eq('tournament_id', LOBBY.state.tournamentId)
                .eq('round_index', TOURNAMENT.currentRound);

            if (error) {
                showToast('Error loading results', 'error');
                return;
            }

            const entries = (roundScores || []).sort((a, b) => b.total_score - a.total_score);

            let html = `
                <div class="drawing-card" style="align-items: stretch; max-width: 800px; margin: 0 auto;">
                    <h2 style="text-align:center; margin-bottom: 8px;">
                        Standings: ${TOURNAMENT.currentRound === 1 ? 'Qualification' : 'Final'}
                    </h2>
                    <p style="text-align:center; color:var(--c-text-muted); margin-bottom: 20px;">
                        The dawg gave these scores
                    </p>
                    <div style="overflow-x: auto;">
                        <table style="width:100%; border-collapse: collapse; text-align: left;">
                            <thead>
                                <tr style="border-bottom: 2px solid var(--c-surface-alt); color: var(--c-text-muted); font-size: 0.85rem;">
                                    <th style="padding: 12px 8px;">#</th>
                                    <th style="padding: 12px 8px;">Player</th>
                                    <th style="padding: 12px 8px;">Shape</th>
                                    <th style="padding: 12px 8px;">Color</th>
                                    <th style="padding: 12px 8px;">TOTAL</th>
                                    <th style="padding: 12px 8px;">STATUS</th>
                                </tr>
                            </thead>
                            <tbody>
            `;

            entries.forEach((entry, index) => {
                const isMe = entry.player_id === LOBBY.state.playerId;
                const playerName = entry.tournament_players?.player_name || 'Unknown';
                
                let statusBadge = "";
                if (TOURNAMENT.currentRound === 1 && TOURNAMENT.players.length > 2) {
                    statusBadge = index < 2 
                        ? '<span style="color:var(--c-accent-teal); font-weight:bold;">‚úÖ FINALIST</span>' 
                        : '<span style="color:var(--c-accent-rose);">‚ùå Next time better, big dawg</span>';
                } else {
                    statusBadge = index === 0 ? 'üèÜ WINNER' : 'ü•à 2nd DAWG';
                }

                html += `
                    <tr style="border-bottom: 1px solid var(--c-surface-alt); ${isMe ? 'background:#FFF7ED; font-weight:bold;' : ''}">
                        <td style="padding: 12px 8px;">${index + 1}</td>
                        <td style="padding: 12px 8px;">${escapeHtml(playerName)} ${isMe ? '(you)' : ''}</td>
                        <td style="padding: 12px 8px;">${entry.shape_score}%</td>
                        <td style="padding: 12px 8px;">${entry.color_score}%</td>
                        <td style="padding: 12px 8px; font-size: 1.1rem; color: var(--c-primary);">${entry.total_score.toFixed(0)}</td>
                        <td style="padding: 12px 8px; font-size: 0.8rem;">${statusBadge}</td>
                    </tr>
                `;
            });

            html += `</tbody></table></div></div>`;
            container.innerHTML = html;

            const totalRoundsNeeded = TOURNAMENT.players.length > 2 ? 2 : 1;

            if (TOURNAMENT.currentRound < totalRoundsNeeded) {
                const finalists = entries.slice(0, 2).map(e => e.player_id);
                const amIFinalist = finalists.includes(LOBBY.state.playerId);

                if (amIFinalist) {
                    showToast('Congrats big dawg! You reached the final!', 'success');
                    setTimeout(async () => {
                        TOURNAMENT.currentRound++;
                        await client.from('tournaments')
                            .update({ 
                                current_round: TOURNAMENT.currentRound, 
                                round_started_at: new Date().toISOString() 
                            })
                            .eq('id', LOBBY.state.tournamentId);
                        showTournamentDrawingRound();
                    }, 8000);
                } else {
                    setTimeout(() => {
                        container.innerHTML = `
                            <div class="drawing-card" style="text-align:center; padding:40px;">
                                <div style="font-size: 4rem;">üò¢</div>
                                <h2>Unlucky...</h2>
                                <p>Your score wasn't high enough for the final. Better luck next time!</p>
                                <button class="btn-cta" onclick="location.reload()" style="margin-top:20px;">Leave Tournament</button>
                            </div>
                        `;
                    }, 8000);
                }
            } else {
                showToast('Tournament is over, calculating winner...', 'success');
                setTimeout(() => {
                    determineTournamentWinner();
                }, 5000);
            }    
        } 

        async function determineTournamentWinner() {
            try {
                const container = document.getElementById('tournamentResults');
                if (!container) return;

                const { data: allRounds, error } = await client
                    .from('tournament_rounds')
                    .select('*, tournament_players(player_name)')
                    .eq('tournament_id', LOBBY.state.tournamentId);

                if (error || !allRounds) return;

                const totals = {};
                allRounds.forEach(r => {
                    const pid = r.player_id;
                    if (!totals[pid]) {
                        totals[pid] = { name: r.tournament_players?.player_name || 'Unknown', score: 0, id: pid };
                    }
                    totals[pid].score += (Number(r.total_score) || 0);
                });

                const scoreboard = Object.values(totals).sort((a, b) => b.score - a.score);
                const winner = scoreboard[0];
                
                let finalName = document.getElementById('artistName').value.trim();
                if (LOBBY.state.playerId === winner.id && (!finalName || finalName === 'Anonymous')) {
                    const promptedName = prompt("üèÜ Wow you won, you are a real dog drawer! Enter your name in the Hall of Fame:", "");
                    finalName = promptedName ? promptedName.trim() : "Anonymous Legend";
                    document.getElementById('artistName').value = finalName;
                } else {
                    finalName = winner.name;
                }

                document.getElementById('btnSubmit').style.display = 'block';
                const card = container.querySelector('.drawing-card');
                card.innerHTML = `
                    <div style="text-align:center; padding:20px;">
                        <div style="font-size: 4rem;">üèÜ</div>
                        <h2 style="color:var(--c-primary);">TOURNAMENT WINNER</h2>
                        <h1 style="font-size: 3rem; margin: 10px 0;">${escapeHtml(finalName)}</h1>
                        <p style="font-size: 1.2rem;">Final result: <strong>${winner.score.toFixed(0)}</strong> points</p>
                        <hr style="margin: 20px 0; opacity: 0.2;">
                        <button class="btn-cta" onclick="location.reload()">Leave Tournament</button>
                    </div>
                `;

                if (LOBBY.state.playerId === winner.id) {
                    await client.from('tournament_winners').insert([{
                        tournament_id: LOBBY.state.tournamentId,
                        winner_name: finalName,
                        final_score: winner.score,
                        player_count: scoreboard.length
                    }]);
                    showToast('You reached the Hall of Fame! üêæ', 'success');
                }
            } catch (err) {
                console.error("Error determining winner:", err);
            }
        }

        async function loadTournamentHallOfFame() {
            const container = document.getElementById('tournamentHallOfFame');
            const listEl = document.getElementById('tournamentHallOfFameList');
            if (!container || !listEl) return;

            const { data, error } = await client
                .from('tournament_winners')
                .select('*')
                .order('completed_at', { ascending: false })
                .limit(20);

            if (error || !data || data.length === 0) {
                container.style.display = 'none';
                return;
            }

            container.style.display = 'block';
            listEl.innerHTML = data.map((w, index) => `
                <div class="rank-row">
                    <div class="rank-num ${index === 0 ? 'rank-1' : index === 1 ? 'rank-2' : index === 2 ? 'rank-3' : ''}">
                        ${index + 1}
                    </div>
                    <div>
                        <div style="font-weight:700;">${w.winner_name || 'Anonymous winner'}</div>
                        <div style="font-size:0.85rem; color: var(--c-text-muted);">
                            Players: ${w.player_count || '?'} ‚Ä¢ Score: ${w.final_score || '?'}
                        </div>
                    </div>
                </div>
            `).join('');
        }

        // --- UTILS & HELPERS ---
        function activateTab(tabId) {
            document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
            document.getElementById(tabId).classList.add('active');
            
            document.querySelectorAll('.nav-tab').forEach(el => el.classList.remove('active'));
            const index = ['draw', 'gallery', 'leaderboard', 'accuracy', 'tournament'].indexOf(tabId);
            if(index >= 0) document.querySelectorAll('.nav-tab')[index].classList.add('active');

            if(tabId === 'gallery') renderGallery();
            if(tabId === 'leaderboard') renderLeaderboard();
            if(tabId === 'accuracy') renderAccuracy();
            if (tabId === 'tournament') {
                loadTournamentHallOfFame();
            }
        }
        function openModal(imgSrc, artistName) {
            const modal = document.getElementById('artModal');
            const modalImg = document.getElementById('modalImg');
            const captionText = document.getElementById('modalCaption');
            
            modal.style.display = "block";
            modalImg.src = imgSrc;
            captionText.innerHTML = "By: " + artistName;
            document.body.style.overflow = 'hidden';
        }
        function closeModal() {
            document.getElementById('artModal').style.display = "none";
            document.body.style.overflow = 'auto';
        }
        function downloadCanvasImage() {
            const img = document.getElementById('modalImg');
            if (!img || !img.src) { showToast('No image found', 'error'); return; }
            const link = document.createElement('a');
            link.download = 'dog-masterpiece.png';
            link.href = img.src;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        function saveData() {
            localStorage.setItem('hddc_drawings', JSON.stringify(STATE.drawings));
            localStorage.setItem('hddc_votes', JSON.stringify([...STATE.myVotes]));
            updateGlobalStats();
        }
        function updateGlobalStats() {
            document.getElementById('statTotalDrawings').textContent = STATE.drawings.length;
            const totalVotes = STATE.drawings.reduce((sum, d) => sum + d.votes, 0);
            document.getElementById('statTotalVotes').textContent = totalVotes;
        }
        function showToast(msg, type) {
            const t = document.getElementById('toast');
            t.textContent = msg;
            t.className = `toast show ${type}`;
            setTimeout(() => t.className = 'toast', 3000);
        }
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // --- EVENT BINDINGS ---
        document.getElementById('btnUndo').onclick = undo;
        document.getElementById('btnClear').onclick = () => { ctx.fillStyle='#FFFFFF'; ctx.fillRect(0,0,canvas.width,canvas.height); saveHistory(); };
        
        const tools = { btnPen: 'pen', btnBrush: 'brush', btnCalligraphy: 'calligraphy', btnEraser: 'eraser', btnFill: 'fill' };
        Object.keys(tools).forEach(id => {
            document.getElementById(id).onclick = (e) => {
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                document.getElementById(id).classList.add('active');
                STATE.tool = tools[id];
            };
        });

        document.getElementById('colorPicker').onchange = (e) => STATE.color = e.target.value;
        document.getElementById('sizeSlider').oninput = (e) => STATE.baseLineWidth = e.target.value;
        document.getElementById('toggleRef').onchange = updateOverlay;
        document.getElementById('opacitySlider').oninput = updateOverlay;

        // --- LOAD DATA ---
        window.addEventListener('load', async function() {
            init();
            await loadDrawingsFromSupabase();
            document.getElementById('btnSubmit').addEventListener('click', publishDrawingToSupabase);
        });

        async function publishDrawingToSupabase() {
            const titleInput = document.getElementById('dogTitle');
            const artistInput = document.getElementById('artistName');

            const title = titleInput.value.trim();
            const artist = artistInput.value.trim();
            const imageData = canvas.toDataURL();
            const scores = calculateAccuracy();

            if (!title || !artist) {
                alert('Please fill in title and artist name!');
                return;
            }

            try {
                const { data, error } = await client
                .from('drawings')
                .insert([{ 
                    title: title, 
                    artist_name: artist, 
                    image_data: imageData,
                    scores: scores,
                    votes: 0 
                }]);

                if (error) throw error;

                showToast('Drawing published to Supabase! üéâ', 'success');
                titleInput.value = '';
                artistInput.value = '';
                // Reset canvas
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                STATE.history = [];
                STATE.historyStep = -1;

                await loadDrawingsFromSupabase();
                renderGallery();
            } catch (err) {
                console.error('Error publishing:', err);
                showToast('Error saving to Supabase!', 'error');
            }
        }

        async function loadDrawingsFromSupabase() {
            try {
                const { data, error } = await client
                .from('drawings')
                .select('*')
                .order('votes', { ascending: false });

                if (error) throw error;

                STATE.drawings = data.map(d => ({
                    id: d.id,
                    artist: d.artist_name,
                    image: d.image_data,
                    votes: d.votes,
                    scores: d.scores || { total: 0, color: 0, shape: 0 },
                    timestamp: new Date(d.created_at).getTime(),
                    isLocal: false
                }));
            } catch (err) {
                console.error('Error loading drawings:', err);
            }
        }
    </script>
</body>
</html>
